#!/bin/ksh
###testb
# lines between ###testb and ###teste not needed for production
###teste
echo `date` $0 begin
################################################################################
#   Script:	exgefs_init.sh.sms
#
#   Author:	Mark Iredell
#   Date:	1997 January 08
#
#   Steward:	Richard Wobus
#   Center:	Environmental Modeling Center
#   Phone:	(301) 763-8000 x7712
#
#   Abstract:	Creates initial conditions for the global ensemble
#       	by perturbing the analysis with growing modes
#               extracted from the previous day's ensemble forecasts.
#       	This script is called by jobs JENS0 and JENS2 and calls
#               the utility script enstr_pair.sh to process each pair.
#
#   Modified:   12/11/98	replace hardwired globampl with fixed file
#                               save growth rate output file
#   Modified:   06/08/99	dummy script made to hold over on IBM until real
#                               exenstr.sh.sms script is ready
#   Modified:   09/09/99	modified for IBM SP
#   Modified:   04/17/00	increase to 5 pairs at 12z
#   Modified:   05/19/00	create perturbation at any two resolutions,
#                               currently set to create 5 pairs and a 
#                               low-resolution control run at T126
#   Modified:   04/30/01	generalize to run with create any number of
#                               levels and any number of tracer variables
#   Modified:   07/01/03        separate into outer and inner (single pair)
#                               scripts
#   Modified:   06/24/05        modify for relocation and 6-hour breeding
#   Modified:   09/09/05        use one-sided names with two-sided breeding
#   Modified:   12/18/12        adapted to ensemble TC tracking
#
################################################################################

set +xa
echo " ------------------------------------------------------------"
echo "  "
echo "            GLOBAL ENSEMBLE INITIALIZATION "
echo "  "
echo "                `date`     "
echo "  "
echo "                   JOB  $job  "
echo "  "
echo "  "
echo "               FORECAST cycle TIME is $cycle"
echo "  "
echo " ------------------------------------------------------------"
echo "          processing info for this execution"
echo " Home directory is ............................ $HOMEGLOBAL"
echo " Processing directory for files.. ............. $DATA"
echo "  "
echo " Executable file directory is ................. $EXECGLOBAL"
echo " Fixed field directory is ..................... $FIXgsm"
echo " Parameter directory is ....................... $PARMGLOBAL"
echo " Unix control language file is ................ $USHGLOBAL"
echo "  "
echo " Network id is ................................ $NET"
echo " Run id for $com processing is ................ $RUN"
echo "  "
echo " standard output in file ...................... $pgmout"
echo " unique processing id for run ................. $pid"
echo " YES SENDCOM means save com files ............. $SENDCOM"
echo " ------------------------------------------------------------"
set -xa

cd $DATA
DATATMP=$DATA

################################################################################

relocfact=$relocfact relocflag=$relocflag

(( npairt = npair * 4 ))
nlist=
ipair=0
while (( ipair < npairt ))
do
  (( ipair = ipair + 1 ))
  if (( ipair < 10 )); then
    ipair=0$ipair
  fi
  nlist="$nlist $ipair"
done
echo nlist=$nlist

# cfsuffix identifies long forecast cycle 
# associated with this breeding job

if [[ "$cycsuffix" = "true" ]]; then
  export cfsuffix=".cycfs$cyc_fcst"
  export ensshort=yes
else
  export cfsuffix=""
  export ensshort=no
fi

echo cyc=$cyc cyc_fcst=$cyc_fcst
echo cycle=$cycle cycle_fcst=$cycle_fcst
echo fcstlong=$fcstlong
echo cycsuffix=$cycsuffix
echo cfsuffix=$cfsuffix
echo ensshort=$ensshort

export pdysave=$PDY
export pdycycp=`$NDATE -$fhrp $PDY$cyc`
export pdyp=`echo $pdycycp|cut -c1-8`
export cycp=`echo $pdycycp|cut -c9-10`

echo pdycycp=$pdycycp pdyp=$pdyp cycp=$cycp

echo  COMINenkf=$COMINenkf

export COM=$COMOUTprevcyc/track_enkf
mkdir -m 775 -p  $COM
# cfsuffixp identifies long forecast cycle
# associated with the previous forecast cycle
# from which tracking information will be used

if (( cycp != cyc_fcst )); then
  export cfsuffixp=".cycfs$cyc_fcst"
  export ensshortp=yes
else
  export cfsuffixp=""
  export ensshortp=no
fi

echo cfsuffixp=$cfsuffixp
echo ensshortp=$ensshortp

#
# begin TC tracker section for c00 (ensemble mean)
#
echo relocflag=$relocflag

(( trackflag = relocflag ))
export relocflag
export trackflag
export COMOUT=${COMOUT}

#### EnKF 6h fcst ensemble mean file name 

  if [ $NEMSIO_IN = .true. ]; then
      fenkffcst6hmean=gdas.t${cycp}z.atmf`printf "%3.3d" $fhrp`.ensmean.nemsio
      runchgres=yes
  else
      fenkffcst6hmean=sfg_${pdycycp}_fhr${fhrp}_ensmean
  fi

### chgres ENKF control run forecast hr=$fhrp and save to precious cycle sfcsig directory 
if (( trackflag == 1 )); then
  # test for files necessary for relocation

  if [[ ! -s ${COMINenkf}${pdyp}/${cycp}/${fenkffcst6hmean} ]]; then
    export trackflag=0
    echo  ${COMINenkf}${pdyp}/${cycp}/${fenkffcst6hmean} not found
  else
   mkdir $COMOUTprevcyc/sfcsig_enkf
   export SIGINP=$COMINenkf${pdyp}/${cycp}/${fenkffcst6hmean}
   export SIGOUT=$COMOUTprevcyc/sfcsig_enkf/gec00.t${cycp}z.sf${fhrp}

    export JCAP=$JCAPHR
    export LEVS=$LEVSHR
    export LONB=$LONBHR
    export LATB=$LATBHR
    export NTRAC=$NTRACHR
    export IDVC=$IDVC

#check if ENKF has same resolution as GEFS
           if [ $NEMSIO_IN = .true. ]; then
                runchgres=yes
           else 
               ojcap=`$sighdrexec $SIGINP jcap`
               olevs=`$sighdrexec $SIGINP levs`
               olonb=`$sighdrexec $SIGINP lonb`
               olatb=`$sighdrexec $SIGINP latb`
               ontrac=`$sighdrexec $SIGINP ntrac`
               oidvc=`$sighdrexec $SIGINP idvc`
               runchgres=yes
               if (( JCAP == ojcap )); then
                    if (( LEVS == olevs )); then
                       if (( LONB == olonb )); then
                         if (( LATB == olatb )); then
                            if (( NTRAC == ontrac )); then
                                if (( IDVC == oidvc )); then
                                    runchgres=no
                                fi
                            fi
                         fi
                       fi
                    fi
                fi
           fi

  if [[ $runchgres = yes ]]; then
    export NVCOORD=$IDVC
    export nopdpvv=$nopdpvv
export LSOIL=4
export IDRT=4
export IALB=0
export IDVM=0
export CLIMO_FIELDS_OPT=3
export LANDICE_OPT=2
export SOILTYPE_INP=statsgo
export SOILTYPE_OUT=zobler
export VEGTYPE_INP=igbp
export VEGTYPE_OUT=sib
export SEA_ICE_THRESHLD_OUTPUT="0.50"
export FNALBC2=$FIXgsm/global_albedo4.1x1.grb
export FNZORC=sib
export FNTSFC=$FIXgsm/RTGSST.1982.2012.monthly.clim.grb
export FNAISC=$FIXgsm/CFSR.SEAICE.1982.2012.monthly.clim.grb

    export CHGRESVARS="use_ufo=.true.,idvt=21,idsl=1,IDVM=$IDVM,idvc=$IDVC,OUTTYP=$OUTTYP,NTRAC=$NTRACLR,NVCOORD=$NVCOORD,IALB=0,nopdpvv=$nopdpvv"
    export OUTTYP=$OUTTYP
    if (( IDVC == 1 )); then
      export SIGLEVEL=$FIXgsm/global_siglevel.l${LEVS}.txt
    fi
    if (( IDVC == 2 )); then
      export SIGLEVEL=$FIXgsm/global_hyblev.l${LEVS}.txt
    fi
    $chgresush 
#    $chgresush >>$pgmout
  else
    cp -fp $SIGINP $SIGOUT
  fi

 fi 
fi

if (( trackflag == 1 )); then
   echo  ${COMINenkf}${pdyp}/${cycp}/${fenkffcst6hmean}
  # test for files necessary for relocation
  if [[ ! -s ${COMINenkf}${pdyp}/${cycp}/${fenkffcst6hmean} ]] ; then
    export trackflag=0
    echo  ${COMINenkf}${pdyp}/${cycp}/${fenkffcst6hmean} not found
  else
    export cmodel=enkf
    export pert=ac00
    export PDY=${pdyp}
    export CYL=${cycp}
    export SIGVAL="&siginfo sigpath=\"${DATA}/sigf_${pert}_fhr\", ddeg=1.0, reslch=0 0 /"
    if [ $NEMSIO_IN = .true. ]; then
       ln -sf $COMOUTprevcyc/sfcsig_enkf/gec00.t${cycp}z.sf${fhrp} ${DATA}/sigf_${pert}_fhr00
       ln -sf $COMOUTprevcyc/sfcsig_enkf/gec00.t${cycp}z.sf${fhrp} ${DATA}/sigf_${pert}_fhr06
    else
       ln -sf $COMINenkf${pdyp}/${cycp}/sfg_${pdycycp}_fhr${fhrp}_ensmean ${DATA}/sigf_${pert}_fhr00
       ln -sf $COMINenkf${pdyp}/${cycp}/sfg_${pdycycp}_fhr${fhrp}_ensmean ${DATA}/sigf_${pert}_fhr06
    fi
      sh $UTILgefs/ush/extrkr.sh

    atcfout=''
    case $cycp in
      (00) atcfout='wc00' ;;
      (06) atcfout='xc00' ;;
      (12) atcfout='yc00' ;;
      (18) atcfout='zc00' ;;
    esac
    atcfoutb=`echo ${atcfout} | tr '[a-z]' '[A-Z]'`
    cat ${COM}/ac00.t${cycp}z.cyclone.trackatcfunix | sed -e 's/AC00/'${atcfoutb}'/g' > ${COM}/${atcfout}.t${cycp}z.cyclone.trackatcfunix
###teste
  fi
fi
export PDY=$pdysave
echo
if [ $NEMSIO_IN = .true. ]; then
echo `date` $0 poe EnKF_track begin
echo

ls -al poescript*
rm -rf poescript*

(( itask = 0 ))
while (( itask < initseparatetasks ))
do
  echo 'echo `date` ############ poescript'" $itask begin">>poescript.$itask
  (( itask = itask + 1 ))

done

(( itask = 0 ))
for ipair in $nlist
do
  echo npair=$npair
  if (( ipair <= npair )); then
    (( ipairh = ipair ))
    suf="wp"
  elif (( ipair <= 2 * npair )); then
    (( ipairh = ipair - npair ))
    suf="xp"
  elif (( ipair <= 3 * npair )); then
    (( ipairh = ipair - 2 * npair ))
    suf="yp"
  else
    (( ipairh = ipair - 3 * npair ))
    suf="zp"
  fi
  (( pmem = 2 * ipair - 1 ))
  (( mmem = 2 * ipair ))
  (( pmemh = 2 * ipairh - 1 ))
  (( mmemh = 2 * ipairh ))
  if [ ${pmem} -lt 10 ]; then
    pmem=0${pmem}
  fi
  if [ ${mmem} -lt 10 ]; then
    mmem=0${mmem}
  fi
  if [ ${pmemh} -lt 10 ]; then
    pmemh=0${pmemh}
  fi
  if [ ${mmemh} -lt 10 ]; then
    mmemh=0${mmemh}
  fi
# loop to find enkf input files
     haveinput=no
    (( fhr = $fhrp ))
       while (( fhr <= $fhrpend ))
           do
         if (( fhr < 10 )); then
             fhr=0$fhr
         fi
         echo begin loop for  fhr=$fhr
         pdycycp0=`$NDATE -$fhr $PDY$cyc`
         pdyp0=`echo $pdycycp0|cut -c1-8`
         cycp0=`echo $pdycycp0|cut -c9-10`
         datein=${pdycycp0}
         if [[ $haveinput = no ]]; then
            found=true
           if   [[ $NEMSIO_IN = .true. ]]; then
                fcstinn=$COMINenkf${pdyp0}/${cycp0}/mem0${mmem}/gdas.t${cycp0}z.atmf`printf "%3.3d" $fhrp`.nemsio
                fcstinp=$COMINenkf${pdyp0}/${cycp0}/mem0${pmem}/gdas.t${cycp0}z.atmf`printf "%3.3d" $fhrp`.nemsio
           else
                fcstinn=$COMINenkf${pdyp0}/${cycp0}/sfg_${pdycycp0}_fhr${fhrp}_mem0${mmem}
                fcstinp=$COMINenkf${pdyp0}/${cycp0}/sfg_${pdycycp0}_fhr${fhrp}_mem0${pmem}
           fi
			if [[ -e $fcstinn ]]; then
				echo fcstinn=$fcstinn found
                                echo fcstinn=$fcstinn found
                               if [ $NEMSIO_IN = .true. ]; then
                                onifhr=$($nemsioget $fcstinn nfhour |grep -i "nfhour" |awk -F"= " '{print $2}' |awk -F" " '{print $1}')
                               else

				onifhr=`$sighdrexec $fcstinn ifhr`
                               fi
				rc=$?
				echo rc=$rc onifhr=$onifhr
				if (( rc == 0 )); then
					if (( onifhr == fhrp )); then
                                                if [ $NEMSIO_IN = .true. ];then
                                                   export OCDATE_NEMS=$($nemsioget ${fcstinn} idate | grep -i "idate" |awk -F= '{print $2}')
                                                   INI_YEAR=$(echo $OCDATE_NEMS | awk -F" " '{print $1}')
                                                   INI_MONTH=$(echo $OCDATE_NEMS | awk -F" " '{print $2}')
                                                   INI_DAY=$(echo $OCDATE_NEMS | awk -F" " '{print $3}')
                                                   INI_HOUR=$(echo $OCDATE_NEMS | awk -F" " '{print $4}')
                                                   oyyyy=$INI_YEAR
                                                   omm=$INI_MONTH; if [ $omm -lt 10 ]; then omm=0$omm ; fi
                                                   odd=$INI_DAY; if [ $odd -lt 10 ]; then odd=0$odd ; fi
                                                   ohh=`expr $INI_HOUR + 0 `; if [ $ohh -lt 10 ]; then ohh=0$ohh ; fi
                                                   onidate=${oyyyy}${omm}${odd}${ohh}
                                                else

						onidate=`$sighdrexec $fcstinn idate`
                                               fi
						rc=$?
						echo rc=$rc onidate=$onidate
						if (( rc == 0 )); then
							if (( onidate == datein )); then
								echo "fcstinn=$fcstinn appears to be usable"
								fcstinnuse=$fcstinn
							else
								found=false
							fi # (( onidate == datein ))
						else
							found=false
						fi # (( rc == 0 ))
					else
						found=false
					fi # (( onifhr == fhrp ))
				else
					found=false
				fi # (( rc == 0 ))
			else
				echo fcstinn=$fcstinn not found
				found=false
			fi # [[ -e $fcstinn ]]
			echo found=$found

			if [[ -e $fcstinp ]]; then
				echo fcstinp=$fcstinp found
                               if [ $NEMSIO_IN = .true. ]; then
                                opifhr=$($nemsioget $fcstinp nfhour |grep -i "nfhour" |awk -F"= " '{print $2}' |awk -F" " '{print $1}')
                               else
				opifhr=`$sighdrexec $fcstinp ifhr`
                               fi
				rc=$?
				echo opifhr=$opifhr
				if (( rc == 0 )); then
					if (( opifhr == fhrp )); then
                                            if [ $NEMSIO_IN = .true. ];then
                                                   export OCDATE_NEMS=$($nemsioget ${fcstinp} idate | grep -i "idate" |awk -F= '{print $2}')
                                                   INI_YEAR=$(echo $OCDATE_NEMS | awk -F" " '{print $1}')
                                                   INI_MONTH=$(echo $OCDATE_NEMS | awk -F" " '{print $2}')
                                                   INI_DAY=$(echo $OCDATE_NEMS | awk -F" " '{print $3}')
                                                   INI_HOUR=$(echo $OCDATE_NEMS | awk -F" " '{print $4}')
                                                   oyyyy=$INI_YEAR
                                                   omm=$INI_MONTH; if [ $omm -lt 10 ]; then omm=0$omm ; fi
                                                   odd=$INI_DAY; if [ $odd -lt 10 ]; then odd=0$odd ; fi
                                                   ohh=`expr $INI_HOUR + 0 `; if [ $ohh -lt 10 ]; then ohh=0$ohh ; fi
                                                   opidate=${oyyyy}${omm}${odd}${ohh}
                                                else
						opidate=`$sighdrexec $fcstinp idate`
                                                fi
						rc=$?
						echo rc=$rc opidate=$opidate
						if (( rc == 0 )); then
							if (( opidate == datein )); then
								echo fcstinp=$fcstinp appears to be usable
								fcstinpuse=$fcstinp
							else
								found=false
							fi # (( opidate == datein ))
						else
							found=false
						fi # (( rc == 0 ))
					else
						found=false
					fi # (( opifhr == fhrp ))
				else
					found=false
				fi # (( rc == 0 ))
			else
				echo fcstinp=$fcstinp not found
				found=false
			fi # [[ -e $fcstinp ]]
			echo found=$found
                          if [[ $found = true ]]; then
                                ifhruse=$fhr
                                echo all forecasts found for ifhruse=$ifhruse
                                        fcstinnuse=$fcstinn
                                        fcstinpuse=$fcstinp
                                haveinput=yes
                        else
                                echo some forecasts missing for fhr=$fhr
                        fi # [[ $found = true ]]


         fi

         (( fhr = fhr + fhrp ))

       done

# end the loop to find enkf input files

  echo 'echo `date` ###### `uname -a` ######'" $ipair $ipairh begin">>poescript.$itask
  cat <<EOF >> poescript.$itask
export DATA=${DATATMP}/tr${ipair}
mkdir -p \${DATA}
export cmodel=enkf
export PDY=${pdyp}
export CYL=${cycp}
export nopdpvv=$nopdpvv
export runchgres=$runchgres
export trackflag=$trackflag
export NEMSIO_IN=$NEMSIO_IN
export haveinput=$haveinput
if  [[ \$runchgres = yes ]] &&  [[ \$haveinput = yes ]] ; then
     export CHGRESVARS="use_ufo=.true.,idvt=21,idsl=1,idvm=$IDVM,idvc=$IDVC,OUTTYP=$OUTTYP,NTRAC=$NTRACLR,NVCOORD=$NVCOORD,IALB=0,nopdpvv=$nopdpvv"
    export SIGLEVEL=$SIGLEVEL
     export SIGINP=$fcstinnuse
     export SIGOUT=$COMOUTprevcyc/sfcsig_enkf/sfg_${pdycycp}_fhr${fhrp}_mem0${mmem}
   $chgresush >>$pgmout
   export SIGINP=$fcstinpuse
   export SIGOUT=$COMOUTprevcyc/sfcsig_enkf/sfg_${pdycycp}_fhr${fhrp}_mem0${pmem}
   $chgresush >>$pgmout
fi


EOF
  cat <<EOF >> poescript.$itask
if (( trackflag == 1 )); then
export pert=${suf}${pmemh}
export SIGVAL="&siginfo sigpath=\"\${DATA}/sigf_\${pert}_fhr\", ddeg=1.0, reslch=0 0 /"
 if   [[ \$NEMSIO_IN = .true. ]]; then
           ln -sf $COMOUTprevcyc/sfcsig_enkf/sfg_${pdycycp}_fhr${fhrp}_mem0${pmem} \${DATA}/sigf_\${pert}_fhr00
           ln -sf $COMOUTprevcyc/sfcsig_enkf/sfg_${pdycycp}_fhr${fhrp}_mem0${pmem} \${DATA}/sigf_\${pert}_fhr06
  else
          ln -sf $COMINenkf/${cycp}/sfg_${pdycycp}_fhr${fhrp}_mem0${pmem} \${DATA}/sigf_\${pert}_fhr00
          ln -sf $COMINenkf/${cycp}/sfg_${pdycycp}_fhr${fhrp}_mem0${pmem} \${DATA}/sigf_\${pert}_fhr06
  fi

$UTILgefs/ush/extrkr.sh > ushout.track.$ipair 2>&1

export pert=${suf}${mmemh}
export SIGVAL="&siginfo sigpath=\"\${DATA}/sigf_\${pert}_fhr\", ddeg=1.0, reslch=0 0 /"
 if   [[ \$NEMSIO_IN = .true. ]]; then
        ln -sf $COMOUTprevcyc/sfcsig_enkf/sfg_${pdycycp}_fhr${fhrp}_mem0${mmem} \${DATA}/sigf_\${pert}_fhr00
        ln -sf $COMOUTprevcyc/sfcsig_enkf/sfg_${pdycycp}_fhr${fhrp}_mem0${mmem} \${DATA}/sigf_\${pert}_fhr06
  else
        ln -sf $COMINenkf/${cycp}/siganl_${pdycycp}_mem0${mmem} \${DATA}/sigf_\${pert}_fhr00
        ln -sf $COMINenkf/${cycp}/sfg_${pdycycp}_fhr${fhrp}_mem0${mmem} \${DATA}/sigf_\${pert}_fhr06
 fi
$UTILgefs/ush/extrkr.sh >> ushout.track.$ipair 2>&1
fi
EOF
  echo 'echo `date` ###### `uname -a` ######'" $ipair $ipairh end">>poescript.$itask

  (( itask = itask + 1 ))
  if (( itask == initseparatetasks )); then
    (( itask = 0 ))
  fi

done

(( itask = 0 ))
while (( itask < initseparatetasks ))
do
  echo 'echo `date` ############ poescript'" $itask end">>poescript.$itask
  echo
  chmod 755 poescript.$itask
  ls -al poescript.$itask
  echo
  cat poescript.$itask
  echo
  echo "sh poescript.$itask" >>poescript
  (( itask = itask + 1 ))
done

echo
chmod 755 poescript
ls -al $poescript
echo
cat poescript
echo

export MP_HOLDTIME=1000

export MP_PGMMODEL=mpmd
export MP_CMDFILE=poescript
export MP_LABELIO=yes
export MP_INFOLEVEL=3
export MP_STDOUTMODE=unordered

echo
echo before ls before poe
echo

pwd
ls -ablp
echo
echo DATA=$DATA before poe
#### kate 4/24/2012 #####
echo trackflag=$trackflag
cp poescript cmdfile
#mpiexec_mpt -np $initseparatetasks $execpoe
#$gefsmpexec
echo APRUN=$APRUN
$APRUN
else
echo WARNING: EnKF tracking is off
fi

#### kate 4/24/2012 ##############

echo DATA=$DATA after poe
pwd
ls -ablp

echo
echo after ls after poe
echo

for ipair in $nlist
do
  file=ushout.track.$ipair
  echo "############################### file=$file begin #######################"
  cat $file
  echo "############################### file=$file end ##########################"
  echo

done
echo
echo `date` $0 poe enkf_track end
echo

###testb
#if [[ $envir = prod ]] || [[ $envir = para ]] || [[ $envir = test ]]; then
###teste
msg='ENDED NORMALLY.'
postmsg "$jlogfile" "$msg"

################# END OF SCRIPT #######################
###testb
#else
#  echo skip delete for now
#fi
###teste
echo `date` $0 end
