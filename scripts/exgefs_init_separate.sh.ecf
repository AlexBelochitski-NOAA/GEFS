#!/bin/ksh
###testb
# lines between ###testb and ###teste not needed for production
###teste
echo `date` $0 begin
################################################################################
#   Script:	exgefs_init.sh.sms
#
#
################################################################################

set +xa
echo " ------------------------------------------------------------"
echo "  "
echo "            GLOBAL ENSEMBLE INITIALIZATION "
echo "  "
echo "                `date`     "
echo "  "
echo "                   JOB  $job  "
echo "  "
echo "  "
echo "               FORECAST cycle TIME is $cycle"
echo "  "
echo " ------------------------------------------------------------"
echo "          processing info for this execution"
echo " Home directory is ............................ $HOMEGLOBAL"
echo " Processing directory for files.. ............. $DATA"
echo "  "
echo " Executable file directory is ................. $EXECGLOBAL"
echo " Fixed field directory is ..................... $FIXgsm"
echo " Parameter directory is ....................... $PARMGLOBAL"
echo " Unix control language file is ................ $USHGLOBAL"
echo "  "
echo " Network id is ................................ $NET"
echo " Run id for $com processing is ................ $RUN"
echo "  "
echo " standard output in file ...................... $pgmout"
echo " unique processing id for run ................. $pid"
echo " YES SENDCOM means save com files ............. $SENDCOM"
echo " ------------------------------------------------------------"
set -xa

cd $DATA

################################################################################

relocfact=$relocfact relocflag=$relocflag


echo cyc=$cyc cyc_fcst=$cyc_fcst
echo cycle=$cycle cycle_fcst=$cycle_fcst

#export pdycycp=`/nwprod/util/exec/ndate -$fhrp $PDY$cyc`
export pdycycp=`$NDATE -$fhrp $PDY$cyc`
export pdyp=`echo $pdycycp|cut -c1-8`
export cycp=`echo $pdycycp|cut -c9-10`

echo pdycycp=$pdycycp pdyp=$pdyp cycp=$cycp

# cfsuffixp identifies long forecast cycle
# associated with the previous forecast cycle
# from which tracking information will be used


#
# high resolution center analysis
#

	if [[ -f $COMINgfs/gfs.$cycle.atmanl.nemsio && -f $COMINgfs/gfs.$cycle.sfcanl.nemsio ]]; then
		export SIGINP=$COMINgfs/gfs.$cycle.atmanl.nemsio
		export SIGOUT=./sanl.in
		export SFCINP=$COMINgfs/gfs.$cycle.sfcanl.nemsio
		export SFCOUT=./sfcanl.in
		export NSTINP=$COMINgfs/gfs.$cycle.nstanl.nemsio
		export NSTOUT=./nsnanl.in
		echo $COMINgfs/gfs.$cycle.atmanl.nemsio and $COMINgfs/gfs.$cycle.sfcanl.nemsio  FOUND
	else
		echo !!!! FATAL ERROR !!!!
		echo $COMINgfs/gfs.$cycle.atmanl.nemsio and $COMINgfs/gfs.$cycle.sfcanl.nemsio CANNOT BE FOUND
		exit
	fi # [[ -f $COMINgfs/gfs.$cycle.atmanl.nemsio && -f $COMINgfs/gfs.$cycle.sfcanl.nemsio ]]

	# check for missing or zero-length analysis files

	for file in $SIGINP $SFCINP; do
		if [[ -s $file ]]; then
			ls -al $file
		else
			echo input file $file IS MISSING
			export err=9
			err_chk
		fi # [[ -s $file ]]
	done # for file in $SIGINP $SFCINP
         ln -s $SIGINP $SIGOUT
         ln -s $SFCINP $SFCOUT
         ln -s $NSTINP $NSTOUT



#

# begin relocation splitting section for c00
#
echo relocflag=$relocflag

(( relocpertflag = relocflag ))
export relocflag
export relocpertflag

if (( relocpertflag == 1 )); then
	# test for files necessary for relocation
	if [[ ! -s $COMSFCSIGP/gec00.t${cycp}z.sf$fhrp ]]; then
		export relocpertflag=0
	fi
	if [[ ! -s $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 ]]; then
		export relocpertflag=0
		echo $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 does not exist
	fi
fi # (( relocpertflag == 1 ))

echo HHH TEST 1
if (( relocpertflag == 1 )); then
	echo Separate the storm and environment forecast fields for c00 setup begin

	yy=`echo $PDY|cut -c3-4`
	echo yy=$yy

	# RLW 20131003 modify to point to experimental data
	#if [[ -s /com/gfs/prod/gfs.$PDY/gfs.$cycle.pgrbf00 ]]; then
	export gfsdir=$COMINgfs
	testfile=gfs.$cycle.master.grbf00
	if [[ -s $gfsdir/$testfile ]]; then
		# f00 gfs tracking for relocation
		export cmodel=gfs00
		COM_HOLD=$COM
		export COM=$COMOUT/$cyc/init
		echo `date` extrkr.sh before
		sh ${extrkrsh:-$HOMEgefs/util/ush/extrkr.sh}
		echo `date` extrkr.sh after
		COM=$COM_HOLD
		cat $COMIN/$cyc/init/zgfs.${cycle}.cyclone.trackatcfunix >trackatcfunix.in
	else # [[ -s $gfsdir/$testfile ]]
		# replaced by f00 gfs tracking above but retained for retrospective runs
		if [[ -e $COMINgfs/avn.${cycle}.cyclone.trackatcfunix ]]; then
			cat $COMINgfs/avn.${cycle}.cyclone.trackatcfunix >trackatcfunix.in
		else
			echo $COMINgfs/avn.${cycle}.cyclone.trackatcfunix DOES NOT EXIST
			touch trackatcfunix.in
		fi # [[ -e $COMINgfs/avn.${cycle}.cyclone.trackatcfunix ]]
	fi # [[ -s $gfsdir/$testfile ]]
	ls -al trackatcfunix.in

	if [[ -f $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 ]]; then
		cp -f $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 tcvitals.in
	else
		echo $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 DOES NOT EXIST
		touch tcvitals.in
	fi # [[ -f $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 ]]
	ls -al tcvitals.in

	#DHOU XZHOU changed, production OK?, DH changed it back
	#  $USHgsm/syndataxtrack.sh $PDY $cyc tcvitals.in trackatcfunix.in tcvitals.as
	$USHgefs/syndataxtrack.sh $PDY $cyc tcvitals.in trackatcfunix.in tcvitals.as #ZEUS

	cp -f $COMSFCSIGP/gec00.t${cycp}z.sf$fhrp gec00_presep

	# 20131111 RLW added this missing line
	taufound=no
        tauprefix=m
        cyc_fcst_t=$cycp
		# 20131130 RLW add touch so this file will exist when linked and read
		touch tracks.atcfunix.$cyc
		for file in $COMTRACKP/${tauprefix}???.t${cycp}z.cyclone.trackatcfunix; do
			if [[ -s $file ]]; then
				cat $file >>tracks.atcfunix.$cyc
				taufound=yes
			fi
		done # for file in $COMTRACKP/${tauprefix}???.t${cycp}z.cyclone.trackatcfunix
	if [[ "$taufound" = "no" ]]; then
		export relocpertflag=0
	fi
fi # (( relocpertflag == 1 ))
        echo relocpertflag=$relocpertflag


echo HHH TEST 2

#DHOU, XZHOU added this if block
execseparate=$EXECgefs/gefs_vortex_separate

#
#  relocation splitting section for c00
#
#### begin relocation high resoluton analysis

    

#### begin relocation high resoluton analysis

echo
echo `date` $0 poe separate begin
echo

if (( relocflagana == 1 )); then
cp -pr tcvitals.in tcvitals.as
fi

ls -al poescript*
rm -rf poescript*
    (( itask = 0 ))
           (( imem0 = 0 ))
           (( imema = 0 ))
# For c00
	echo 'echo `date` ############ poescript'" $itask begin">>poescript.$itask
	echo 'echo `date` ###### `uname -a` ######'" mem=$imem start">>poescript.$itask
		echo "$USHgefs/gefs_init_separate.sh $imema $imem0 $fhrp $inflag $relocfact >ushout.separate.$itask 2>&1" >>poescript.$itask
	echo 'echo `date` ###### `uname -a` ######'" mem=$imema end">>poescript.$itask

#  Select EnKF members for four cycling
case $cyc in
                        (00) (( nlist_start = 1 )) ;;
                        (06) (( nlist_start = nmem_enkf / 4 + 1  ));;
                        (12) (( nlist_start = 2 * nmem_enkf / 4 + 1 ));;
                        (18) (( nlist_start = 3 * nmem_enkf / 4 + 1  )) ;;
esac # $cyc


(( nlist_end = nlist_start + npert - 1 ))
    echo EnKF members from $nlist_start to $nlist_end are selected for $cyc cycle

(( itask = 1 ))
(( imem = nlist_start ))

while (( imem <= nlist_end )) ; do
	(( imem0 = imem - nlist_start + 1 ))
	(( imema = imem  )) 
        if ((  imem > nmem_enkf )); then 
                (( imema = imem - nmem_enkf )) 
        fi
	echo 'echo `date` ############ poescript'" $itask begin">>poescript.$itask
	echo 'echo `date` ###### `uname -a` ######'" mem=$imema start">>poescript.$itask
		echo "$USHgefs/gefs_init_separate.sh $imema $imem0 $fhrp $inflag $relocfact >ushout.separate.$itask 2>&1" >>poescript.$itask
	echo 'echo `date` ###### `uname -a` ######'" mem=$imema end">>poescript.$itask

	(( itask = itask + 1 ))
        (( imem = imem + 1 ))
done
if (( relocflagana == 1 )); then
         (( imema = -1 ))
         (( imem0 = -1 ))
         (( fhrp0 = 0 ))
	echo 'echo `date` ############ poescript'" $itask begin">>poescript.$itask
	echo 'echo `date` ###### `uname -a` ######'" mem=$imema start">>poescript.$itask
		echo "$USHgefs/gefs_init_separate.sh $imema $imem0 $fhrp0 $inflag $relocfact >ushout.separate.$itask 2>&1" >>poescript.$itask
	echo 'echo `date` ###### `uname -a` ######'" mem=$imema end">>poescript.$itask
fi


        (( itask = 0 ))
while (( itask <= npert + 1 )); do
	chmod 755 poescript.$itask
	ls -al poescript.$itask
	echo
	cat poescript.$itask
	echo
	echo "poescript.$itask" >>poescript
	(( itask = itask + 1 ))
done # while (( itask < npert ))


echo
chmod 755 poescript
ls -al $poescript
echo
cat poescript
echo
cp -pr poescript cmdfile

echo
echo before ls before poe
echo

pwd
ls -ablp
echo
echo DATA=$DATA before poe
#### kate 4/24/2012 #####
echo "APRUN=$APRUN"
export MP_CMDFILE=poescript
export SCR_CMDFILE=$MP_CMDFILE  # Used by mpiserial on Theia
export MP_PGMMODEL=mpmd
export MP_LABELIO=yes
export MP_INFOLEVEL=3
export MP_STDOUTMODE=unordered

rm mpmd_cmdfile
ln -s $MP_CMDFILE mpmd_cmdfile
$APRUN 

echo DATA=$DATA after poe
pwd
ls -ablp

echo
echo after ls after poe
echo

for itask in {0..$npert}; do
	file=ushout.separate.$itask
	echo "############################### file=$file begin #######################"
	cat $file
	echo "############################### file=$file end ##########################"
	echo
done

echo
echo `date` $0 poe separate end
echo

###testb
#if [[ $envir = prod ]] || [[ $envir = para ]] || [[ $envir = test ]]; then
###teste
msg='ENDED NORMALLY.'
postmsg "$jlogfile" "$msg"

################# END OF SCRIPT #######################
###testb
#else
#  echo skip delete for now
#fi
###teste
echo `date` $0 end
