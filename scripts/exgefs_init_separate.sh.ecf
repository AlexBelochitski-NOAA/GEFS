#!/bin/ksh
###testb
# lines between ###testb and ###teste not needed for production
###teste
echo `date` $0 begin
################################################################################
#   Script:	exgefs_init.sh.sms
#
#   Author:	Mark Iredell
#   Date:	1997 January 08
#
#   Steward:	Richard Wobus
#   Center:	Environmental Modeling Center
#   Phone:	(301) 763-8000 x7712
#
#   Abstract:	Creates initial conditions for the global ensemble
#       	by perturbing the analysis with growing modes
#               extracted from the previous day's ensemble forecasts.
#       	This script is called by jobs JENS0 and JENS2 and calls
#               the utility script enstr_pair.sh to process each pair.
#
#   Modified:   12/11/98	replace hardwired globampl with fixed file
#                               save growth rate output file
#   Modified:   06/08/99	dummy script made to hold over on IBM until real
#                               exenstr.sh.sms script is ready
#   Modified:   09/09/99	modified for IBM SP
#   Modified:   04/17/00	increase to 5 pairs at 12z
#   Modified:   05/19/00	create perturbation at any two resolutions,
#                               currently set to create 5 pairs and a 
#                               low-resolution control run at T126
#   Modified:   04/30/01	generalize to run with create any number of
#                               levels and any number of tracer variables
#   Modified:   07/01/03        separate into outer and inner (single pair)
#                               scripts
#   Modified:   06/24/05        modify for relocation and 6-hour breeding
#   Modified:   09/09/05        use one-sided names with two-sided breeding
#
################################################################################

set +xa
echo " ------------------------------------------------------------"
echo "  "
echo "            GLOBAL ENSEMBLE INITIALIZATION "
echo "  "
echo "                `date`     "
echo "  "
echo "                   JOB  $job  "
echo "  "
echo "  "
echo "               FORECAST cycle TIME is $cycle"
echo "  "
echo " ------------------------------------------------------------"
echo "          processing info for this execution"
echo " Home directory is ............................ $HOMEGLOBAL"
echo " Processing directory for files.. ............. $DATA"
echo "  "
echo " Executable file directory is ................. $EXECGLOBAL"
echo " Fixed field directory is ..................... $FIXGLOBAL"
echo " Parameter directory is ....................... $PARMGLOBAL"
echo " Unix control language file is ................ $USHGLOBAL"
echo "  "
echo " Network id is ................................ $NET"
echo " Run id for $com processing is ................ $RUN"
echo "  "
echo " standard output in file ...................... $pgmout"
echo " unique processing id for run ................. $pid"
echo " YES SENDCOM means save com files ............. $SENDCOM"
echo " ------------------------------------------------------------"
set -xa

cd $DATA
  
################################################################################

relocfact=$relocfact relocflag=$relocflag

(( npairt = npair * 4 ))
nlist=
ipair=0
while (( ipair < npairt ))
do
  (( ipair = ipair + 1 ))
  if (( ipair < 10 )); then
    ipair=0$ipair
  fi
  nlist="$nlist $ipair"
done
echo nlist=$nlist

# explicit jcap specification replaced by specifications in parm file
  
# these variables specify the resolution of low-resolution perturbation output
# JCAPLR=62
# LEVSLR=28
# LONBLR=192
# LATBLR=94
# NTRACLR=3

# these variables specify the resolution of high-resolution perturbation output
# JCAPHR=126
# LEVSHR=28
# LONBHR=384
# LATBHR=190
# NTRACHR=3

# cfsuffix identifies long forecast cycle 
# associated with this breeding job

if [[ "$cycsuffix" = "true" ]]; then
  export cfsuffix=".cycfs$cyc_fcst"
  export ensshort=yes
else
  export cfsuffix=""
  export ensshort=no
fi

echo cyc=$cyc cyc_fcst=$cyc_fcst
echo cycle=$cycle cycle_fcst=$cycle_fcst
echo fcstlong=$fcstlong
echo cycsuffix=$cycsuffix
echo cfsuffix=$cfsuffix
echo ensshort=$ensshort

export pdycycp=`/nwprod/util/exec/ndate -$fhrp $PDY$cyc`
export pdyp=`echo $pdycycp|cut -c1-8`
export cycp=`echo $pdycycp|cut -c9-10`

echo pdycycp=$pdycycp pdyp=$pdyp cycp=$cycp

# cfsuffixp identifies long forecast cycle
# associated with the previous forecast cycle
# from which tracking information will be used

if (( cycp != cyc_fcst )); then
  export cfsuffixp=".cycfs$cyc_fcst"
  export ensshortp=yes
else
  export cfsuffixp=""
  export ensshortp=no
fi

echo cfsuffixp=$cfsuffixp
echo ensshortp=$ensshortp

#
# low resolution center analysis
#

if (( nhrpair < npair )); then

  export SIGOUT=sanl.lr.in
  export SFCOUT=sfcanl.lr.in

  export JCAP=$JCAPLR
  export LEVS=$LEVSLR
  export LONB=$LONBLR
  export LATB=$LATBLR
  export NTRAC=$NTRACLR
  export IDVC=$IDVC
  export NVCOORD=$IDVC
  export CHGRESVARS="NTRAC=$NTRACLR,NVCOORD=$NVCOORD,IALB=0"
  if (( IDVC == 1 )); then
    export SIGLEVEL=$FIXGLOBAL/global_siglevel.l${LEVS}.txt
  fi
  if (( IDVC == 2 )); then
    export SIGLEVEL=$FIXGLOBAL/global_hyblev.l${LEVS}.txt
  fi

###testb
  if [[ $envir = prod ]]; then
###teste
  export SIGINP=$GFSCOMIN/gfs.$cycle.sanl
  export SFCINP=$GFSCOMIN/gfs.$cycle.sfcanl
###testb
  else
    export basedgft=/ensemble/noscrub/Dingchen.Hou
    echo $basedgft DHOU-BASEGFS for occational back-up of $basedgfs data
    if [[ -f $GFSCOMIN/gfs.$cycle.sanl && -f $GFSCOMIN/gfs.$cycle.sfcanl ]]; then
      export SIGINP=$GFSCOMIN/gfs.$cycle.sanl
      export SFCINP=$GFSCOMIN/gfs.$cycle.sfcanl
    elif [[ -f $basedgfs$GFSCOMIN/gfs.$cycle.sanl && -f $basedgfs$GFSCOMIN/gfs.$cycle.sfcanl ]]; then

      export SIGINP=$basedgfs$GFSCOMIN/gfs.$cycle.sanl
      export SFCINP=$basedgfs$GFSCOMIN/gfs.$cycle.sfcanl
    elif [[ -f $basedgft$GFSCOMIN/gfs.$cycle.sanl && -f $basedgft$GFSCOMIN/gfs.$cycle.sfcanl ]]; then

      export SIGINP=$basedgft$GFSCOMIN/gfs.$cycle.sanl
      export SFCINP=$basedgft$GFSCOMIN/gfs.$cycle.sfcanl
    else
      echo $basedgfs$GFSCOMIN/gfs.$cycle.sanl and $basedgfs$GFSCOMIN/gfs.$cycle.sfcanl CANNOT BE FOUND
      exit
    fi
  fi
###teste

  # check for missing or zero-length analysis files

  for file in $SIGINP $SFCINP
  do
    if [[ -s $file ]]; then
      ls -al $file
    else
      echo input file $file IS MISSING
      export err=9
      err_chk
    fi
  done

  ojcap=`$sighdrexec $SIGINP jcap`
  olevs=`$sighdrexec $SIGINP levs`
  ontrac=`$sighdrexec $SIGINP ntrac`
  oidvc=`$sighdrexec $SIGINP idvc`
  runchgres=yes
  if (( JCAP == ojcap )); then
    if (( LEVS == olevs )); then
      if (( NTRAC == ontrac )); then
	if (( IDVC == oidvc )); then
	  runchgres=no
	fi
      fi
    fi
  fi

  if [[ $runchgres = yes ]]; then
#   if (( IDVC != oidvc )); then
#     if [[ $oidvc != 2 ]] || [[ LEVS != olevs ]]; then
#       export SIGLEVEL=$siglevelfile
#     fi
#   fi
    echo `date` timing lr chgres before
    $chgresush >>$pgmout
    echo `date` timing lr chgres after
  else
    cp -fp $SIGINP $SIGOUT
    cp -fp $SFCINP $SFCOUT
  fi

fi

#
# high resolution center analysis
#

if (( nhrpair > 0 )); then

  export SIGOUT=sanl.hr.in
  export SFCOUT=sfcanl.hr.in

  export JCAP=$JCAPHR
  export LEVS=$LEVSHR
  export LONB=$LONBHR
  export LATB=$LATBHR
  export NTRAC=$NTRACHR
  export IDVC=$IDVC
  export NVCOORD=$IDVC
  export CHGRESVARS="NTRAC=$NTRACLR,NVCOORD=$NVCOORD,IALB=0"
  if (( IDVC == 1 )); then
    export SIGLEVEL=$FIXGLOBAL/global_siglevel.l${LEVS}.txt
  fi
  if (( IDVC == 2 )); then
    export SIGLEVEL=$FIXGLOBAL/global_hyblev.l${LEVS}.txt
  fi

###testb
  if [[ $envir = prod ]]; then
###teste
  export SIGINP=$GFSCOMIN/gfs.$cycle.sanl
  export SFCINP=$GFSCOMIN/gfs.$cycle.sfcanl
###testb
  else
    export basedgft=/ensemble/noscrub/Dingchen.Hou2yy
    echo $basedgft DHOU-BASEGFS for occational back-up of $basedgfs data
    if [[ -f $GFSCOMIN/gfs.$cycle.sanl && -f $GFSCOMIN/gfs.$cycle.sfcanl ]]; then
      export SIGINP=$GFSCOMIN/gfs.$cycle.sanl
      export SFCINP=$GFSCOMIN/gfs.$cycle.sfcanl
    elif [[ -f $basedgfs$GFSCOMIN/gfs.$cycle.sanl && -f $basedgfs$GFSCOMIN/gfs.$cycle.sfcanl ]]; then

      export SIGINP=$basedgfs$GFSCOMIN/gfs.$cycle.sanl
      export SFCINP=$basedgfs$GFSCOMIN/gfs.$cycle.sfcanl
    elif [[ -f $basedgft$GFSCOMIN/gfs.$cycle.sanl && -f $basedgft$GFSCOMIN/gfs.$cycle.sfcanl ]]; then

      export SIGINP=$basedgft$GFSCOMIN/gfs.$cycle.sanl
      export SFCINP=$basedgft$GFSCOMIN/gfs.$cycle.sfcanl
    else
      echo $basedgfs$GFSCOMIN/gfs.$cycle.sanl and $basedgfs$GFSCOMIN/gfs.$cycle.sfcanl CANNOT BE FOUND
      exit
    fi
  fi
###teste

  # check for missing or zero-length analysis files

  for file in $SIGINP $SFCINP
  do
    if [[ -s $file ]]; then
      ls -al $file
    else
      echo input file $file IS MISSING
      export err=9
      err_chk
    fi
  done

  ojcap=`$sighdrexec $SIGINP jcap`
  olevs=`$sighdrexec $SIGINP levs`
  ontrac=`$sighdrexec $SIGINP ntrac`
  oidvc=`$sighdrexec $SIGINP idvc`
  runchgres=yes
  if (( JCAP == ojcap )); then
    if (( LEVS == olevs )); then
      if (( NTRAC == ontrac )); then
	if (( IDVC == oidvc )); then
	  runchgres=no
	fi
      fi
    fi
  fi

  if [[ $runchgres = yes ]]; then
#   if [[ $IDVC = 2 ]]; then
#     if [[ $oidvc != 2 ]] || [[ LEVS != olevs ]]; then
#       export SIGLEVEL=$siglevelfile
#       export NVCOORD=2
#     fi
#   fi
    echo `date` timing hr chgres before
    $chgresush >>$pgmout
    echo `date` timing hr chgres after
  else
    cp -fp $SIGINP $SIGOUT
    cp -fp $SFCINP $SFCOUT
  fi

fi

wait

#
# begin relocation splitting section for c00
#
echo relocflag=$relocflag

(( relocpertflag = relocflag ))
export relocflag
export relocpertflag

if (( relocpertflag == 1 )); then
  # test for files necessary for relocation
  if [[ ! -e $COM/gefs.$pdyp/$cycp/sfcsig/gec00.t${cycp}z.sf$fhrp ]]; then
    export relocpertflag=0
  fi
  if [[ ! -e $GFSCOMIN/gfs.$cycle.syndata.tcvitals.tm00 ]]; then
    if [[ $envir = prod  ]] || [[ $envir = para ]] || [[ $envir = test ]]; then
    export relocpertflag=0
    else
      echo production $GFSCOMIN/gfs.$cycle.syndata.tcvitals.tm00 does not exist
      if [[ ! -e $basedgfs$GFSCOMIN/gfs.$cycle.syndata.tcvitals.tm00 ]]; then
	export relocpertflag=0
      fi
    fi
  fi
fi

if (( relocpertflag == 1 )); then
  echo Separate the storm and environment forecast fields for c00 setup begin

  yy=`echo $PDY|cut -c3-4`
  echo yy=$yy

  case $gfsgribedition in
    (1)
      ####### temporary reference from EMC parallel ############################################################################
      filegfs00=$GFSCOMIN/gfs.${cycle}.master.grbf00
      if [[ -s $filegfs00 ]]; then
        echo analysis tracking for gfsgribedition=$gfsgribedition begin
	# f00 gfs tracking for relocation
	export cmodel=gfs00
	COM_HOLD=$COM
	export COM=$COMOUT/$cyc/init
	sh ${extrkrsh:-$HOMEgefs/util/ush/extrkr.sh}
	COM=$COM_HOLD
#DHOU 01/31/2013,  changed this block back to the ccs version, instead of kate's zeus version 
#   if [[ $envir = prod ]]; then
#   sh ${utilscript}/extrkr.sh
#   elif [[ $envir = para ]] || \
# [[ $envir = test ]]; then
#     sh /nw$envir/util/ush/extrkr.sh
#   else
#     sh $basesource/nw$envir/util/ush/extrkr.sh
#   fi
#   cat $COMIN/$cyc/init/zgfs.${cycle}.cyclone.trackatcfunix >trackatcfunix.in
        echo analysis tracking for gfsgribedition=$gfsgribedition end
      else
        echo search for existiong track file for $gfsgribedition begin
	# replaced by f00 gfs tracking above but retained for retrospective runs
	if [[ $envir = prod ]] || [[ $envir = para ]] || [[ $envir = test ]]; then
	  if [[ -e $GFSCOMIN/avn.${cycle}.cyclone.trackatcfunix ]]; then
	    cat $GFSCOMIN/avn.${cycle}.cyclone.trackatcfunix >trackatcfunix.in
	  fi
	else
	  if [[ -e $GFSCOMIN/avn.${cycle}.cyclone.trackatcfunix ]]; then
	    cat $GFSCOMIN/avn.${cycle}.cyclone.trackatcfunix >trackatcfunix.in
	  elif [[ -e $basedgfs$GFSCOMIN/avn.${cycle}.cyclone.trackatcfunix ]]; then
	    cat $basedgfs$GFSCOMIN/avn.${cycle}.cyclone.trackatcfunix >trackatcfunix.in
	  else 
	    echo $basedgfs$GFSCOMIN/avn.${cycle}.cyclone.trackatcfunix DOES NOT EXIST
	    touch trackatcfunix.in
	  fi
	fi
        echo search for existiong track file for $gfsgribedition end
      fi
    ;;
    (2)
      ####### temporary reference from EMC parallel ############################################################################
      filegfs00=/ensemble/noscrub/Richard.Wobus/o/com/gfs/para/gfs.$PDY/gfs.${cycle}.master.grbf00
      filegfs00=$GFSCOMIN/gfs.${cycle}.pgrb2.0p25.f000
      if [[ -s $filegfs00 ]]; then
        echo analysis tracking for gfsgribedition=$gfsgribedition begin
	# f00 gfs tracking for relocation
	export pertlist="p01"
	for npert in $pertlist
	do
	  export cmodel=gfs
	  export ATCFNAME=zgfs
	  export TRACK_OUT=$COMIN/$cyc/track
	  extrkrsh2=$HOMEgefs/ush/extrkr_2015.sh
	  export homesyndir=`dirname $extrkrsh2`
	  export loopnum=1
	  export ymdh=${PDY}${cyc}
	  outdir=$DATA
	  sh $extrkrsh2 $loopnum $cmodel $ymdh $npert $outdir >${outdir}/trkr.$ymdh.out 2>&1
	done
        echo analysis tracking for gfsgribedition=$gfsgribedition end
      else
        echo search for existiong track file for $gfsgribedition begin
	# replaced by f00 gfs tracking above but retained for retrospective runs
	if [[ $envir = prod ]] || [[ $envir = para ]] || [[ $envir = test ]]; then
	  if [[ -e $GFSCOMIN/avn.${cycle}.cyclone.trackatcfunix ]]; then
	    cat $GFSCOMIN/avn.${cycle}.cyclone.trackatcfunix >trackatcfunix.in
	  else
	    touch trackatcfunix.in
	  fi
	fi
        echo search for existiong track file for $gfsgribedition end
      fi
    ;;
  esac
    ls -al trackatcfunix.in

    if   [[ $envir = prod ]]; then
    cp -f $GFSCOMIN/gfs.$cycle.syndata.tcvitals.tm00 tcvitals.in
    else
      if [[ -f $GFSCOMIN/gfs.$cycle.syndata.tcvitals.tm00 ]]; then
	cp -f $GFSCOMIN/gfs.$cycle.syndata.tcvitals.tm00 tcvitals.in
      elif [[ -f $basedgfs$GFSCOMIN/gfs.$cycle.syndata.tcvitals.tm00 ]]; then
	cp -f $basedgfs$GFSCOMIN/gfs.$cycle.syndata.tcvitals.tm00 tcvitals.in
	else
	echo $basedgfs$GFSCOMIN/gfs.$cycle.syndata.tcvitals.tm00 DOES NOT EXIST
	touch tcvitals.in
      fi
      ls -al tcvitals.in
    fi

  #DHOU XZHOU changed, production OK?, DH changed it back
    $USHGLOBAL/syndataxtrack.sh $PDY $cyc tcvitals.in trackatcfunix.in tcvitals.as
  # $USHgefs/syndataxtrack.sh $PDY $cyc tcvitals.in trackatcfunix.in tcvitals.as #ZEUS

    cp -f $COM/gefs.$pdyp/$cycp/sfcsig/gec00.t${cycp}z.sf$fhrp gec00_presep

    for tauprefix in w x y z
    do
      if [[ $tauprefix = w ]]; then
	cyc_fcst_t=00
      elif [[ $tauprefix = x ]]; then
	cyc_fcst_t=06
      elif [[ $tauprefix = y ]]; then
	cyc_fcst_t=12
      elif [[ $tauprefix = z ]]; then
	cyc_fcst_t=18
      else
	cyc_fcst_t=cyc_fcst
      fi
      for file in $COM/gefs.$pdyp/$cycp/track/${tauprefix}[pc]??.t${cycp}z.cyclone.trackatcfunix
      do
	if [[ -s $file ]]; then
	  cat $file >>tracks.atcfunix.$cyc_fcst_t
	  taufound=yes
	fi
      done
      if [[ "$taufound" = "no" ]]; then
	if (( cyc_fcst == cycp )); then
	  for file in $COM/gefs.$pdyp/$cycp/track/a[pc]??.t${cycp}z.cyclone.trackatcfunix
	  do
	    if [[ -s $file ]]; then
	      cat $file >>tracks.atcfunix.$cyc_fcst_t
	      taufound=yes
	    fi
	  done
	fi
      fi
    done
    if [[ "$taufound" = "no" ]]; then
      export relocpertflag=0
    fi

    echo Separate the storm and environment forecast fields for c00 setup end
  fi

  #DHOU, XZHOU added this if block
  if [[ $envir = prod ]]; then
  execseparate=$EXECGLOBAL/gefs_vortex_separate
  elif [[ $envir = para ]] || [[ $envir = test ]]; then
    # RLW 20141008 modify to obtain and user version for vertical structure
    execseparate=/nw$envir/gefs.${model_ver}/exec/gefs_vortex_separate
  else
  # RLW 20141008 modify to obtain and user version for vertical structure
  execseparate=$basesource/nw$envir/gefs.${model_ver}/exec/gefs_vortex_separate
  execpoe=$basesource/nw$envir/exec/zeus-poe
fi

if (( relocpertflag == 1 )); then
  echo Separate the storm and environment forecast fields for c00 begin

  ln -s -f tcvitals.as fort.11

  ln -s -f $FIXGLOBAL/global_slmask.t$JCAPHR.grb    fort.12

  ln -s -f tracks.atcfunix.$cycp      fort.40
  ln -s -f gec00_presep              fort.21

  ln -s -f gec00_env              fort.51
  ln -s -f gec00_strm              fort.71

  export gesfhr=$fhrp
  export ensm=c00

  echo `date` $execseparate before
  echo $gesfhr $ensm | $execseparate
  filtrccc=$?
  echo `date` $execseparate after

  ls -al gec00_presep gec00_env gec00_strm

  if [[ -s gec00_strm ]]; then
    echo c0 storm file was created
    cp -f gec00_strm gec00_strm.c2
  else
    echo c0 storm file was not created
    export relocpertflag=0
  fi

  echo Separate the storm and environment forecast fields for c00 end
fi
echo relocflag=$relocflag relocpertflag=$relocpertflag
#
# end relocation splitting section for c00
#

echo
echo `date` $0 poe separate begin
echo

ls -al poescript*
rm -rf poescript*

(( itask = 0 ))
while (( itask < initseparatetasks ))
do
  echo 'echo `date` ############ poescript'" $itask begin">>poescript.$itask
  (( itask = itask + 1 ))
done

(( itask = 0 ))
for ipair in $nlist
do
  echo npair=$npair
  if (( ipair <= npair )); then
    (( ipairh = ipair ))
  elif (( ipair <= 2 * npair )); then
    (( ipairh = ipair - npair ))
  elif (( ipair <= 3 * npair )); then
    (( ipairh = ipair - 2 * npair ))
  else
    (( ipairh = ipair - 3 * npair ))
  fi
  echo 'echo `date` ###### `uname -a` ######'" $ipair $ipairh begin">>poescript.$itask
###testb
if [[ $envir = prod ]]; then
###teste
  if (( ipairh > nhrpair )); then
    echo "$USHGLOBAL/gefs_init_pair_separate.sh $ipair $npairt $nhrpair $JCAPLR $LEVSLR $LATBLR $LONBLR $NTRACLR $fhrp $inflag $outflag $relocfact >ushout.separate.$ipair 2>&1" >>poescript.$itask
  else
    echo "$USHGLOBAL/gefs_init_pair_separate.sh $ipair $npairt $nhrpair $JCAPHR $LEVSHR $LATBHR $LONBHR $NTRACHR $fhrp $inflag $outflag $relocfact >ushout.separate.$ipair 2>&1" >>poescript.$itask
  fi
###testb
elif [[ $envir = para ]] || [[ $envir = test ]]; then
  if (( ipairh > nhrpair )); then
    # RLW 20141008 modify to obtain and user version for vertical structure
    echo "/nw$envir/gefs.${model_ver}/ush/gefs_init_pair_separate.sh $ipair $npairt $nhrpair $JCAPLR $LEVSLR $LATBLR $LONBLR $NTRACLR $fhrp $inflag $outflag $relocfact >ushout.separate.$ipair 2>&1" >>poescript.$itask
  else
    # RLW 20141008 modify to obtain and user version for vertical structure
    echo "/nw$envir/gefs.${model_ver}/ush/gefs_init_pair_separate.sh $ipair $npairt $nhrpair $JCAPHR $LEVSHR $LATBHR $LONBHR $NTRACHR $fhrp $inflag $outflag $relocfact >ushout.separate.$ipair 2>&1" >>poescript.$itask
  fi
else
  if (( ipairh > nhrpair )); then
    # RLW 20141008 modify to obtain and user version for vertical structure
    echo "$basesource/nw$envir/gefs.${model_ver}/ush/gefs_init_pair_separate.sh $ipair $npairt $nhrpair $JCAPLR $LEVSLR $LATBLR $LONBLR $NTRACLR $fhrp $inflag $outflag $ushout.separate.$ipair 2>&1 $relocfact" >>poescript.$itask
## kate 04/24/2012
    # RLW 20141008 modify to obtain and user version for vertical structure
    echo "$basesource/nw$envir/gefs.${model_ver}/ush/gefs_init_pair_separate.sh $ipair $npairt $nhrpair $JCAPLR $LEVSLR $LATBLR $LONBLR $NTRACLR $fhrp $inflag $outflag $ushout.separate.$ipair 2>&1 $relocfact" >>cmdfile
## ################kate 04/24/2012
  else
    # RLW 20141008 modify to obtain and user version for vertical structure
    echo "$basesource/nw$envir/gefs.${model_ver}/ush/gefs_init_pair_separate.sh $ipair $npairt $nhrpair $JCAPHR $LEVSHR $LATBHR $LONBHR $NTRACHR $fhrp $inflag $outflag >ushout.separate.$ipair 2>&1 $relocfact" >>poescript.$itask

## kate 04/24/2012
    # RLW 20141008 modify to obtain and user version for vertical structure
    echo "$basesource/nw$envir/gefs.${model_ver}/ush/gefs_init_pair_separate.sh $ipair $npairt $nhrpair $JCAPHR $LEVSHR $LATBHR $LONBHR $NTRACHR $fhrp $inflag $outflag >ushout.separate.$ipair 2>&1 $relocfact" >>cmdfile
## ################kate 04/24/2012
  fi
fi
###teste
  echo 'echo `date` ###### `uname -a` ######'" $ipair $ipairh end">>poescript.$itask

  (( itask = itask + 1 ))
  if (( itask == initseparatetasks )); then
    (( itask = 0 ))
  fi

done

(( itask = 0 ))
while (( itask < initseparatetasks ))
do
  echo 'echo `date` ############ poescript'" $itask end">>poescript.$itask
  echo
  chmod 755 poescript.$itask
  ls -al poescript.$itask
  echo
  cat poescript.$itask
  echo
  echo "poescript.$itask" >>poescript
  (( itask = itask + 1 ))
done

echo
chmod 755 poescript
ls -al $poescript
echo
cat poescript
echo

export MP_HOLDTIME=1000

export MP_PGMMODEL=mpmd
export MP_CMDFILE=poescript
export MP_LABELIO=yes
export MP_INFOLEVEL=3
export MP_STDOUTMODE=unordered

echo
echo before ls before poe
echo

pwd
ls -ablp
echo
echo DATA=$DATA before poe
#### kate 4/24/2012 #####
echo "gefsmpexec=$gefsmpexec"
$gefsmpexec
#### kate 4/24/2012 ##############

echo DATA=$DATA after poe
pwd
ls -ablp

echo
echo after ls after poe
echo

for ipair in $nlist
do
  file=ushout.separate.$ipair
  echo "############################### file=$file begin #######################"
  cat $file
  echo "############################### file=$file end ##########################"
  echo
done

echo
echo `date` $0 poe separate end
echo

###testb
if [[ $envir = prod ]] || [[ $envir = para ]] || [[ $envir = test ]]; then
###teste
msg='ENDED NORMALLY.'
postmsg "$jlogfile" "$msg"

################# END OF SCRIPT #######################
###testb
else
  echo skip delete for now
fi
###teste
echo `date` $0 end
