#!/bin/ksh
###testb
# lines between ###testb and ###teste not needed for production
###teste
echo `date` $0 begin
################################################################################
#   Script:	exgefs_init.sh.sms
#
#   Author:	Mark Iredell
#   Date:	1997 January 08
#
#   Steward:	Richard Wobus
#   Center:	Environmental Modeling Center
#   Phone:	(301) 763-8000 x7712
#
#   Abstract:	Creates initial conditions for the global ensemble
#       	by perturbing the analysis with growing modes
#               extracted from the previous day's ensemble forecasts.
#       	This script is called by jobs JENS0 and JENS2 and calls
#               the utility script enstr_pair.sh to process each pair.
#
#   Modified:   12/11/98	replace hardwired globampl with fixed file
#                               save growth rate output file
#   Modified:   06/08/99	dummy script made to hold over on IBM until real
#                               exenstr.sh.sms script is ready
#   Modified:   09/09/99	modified for IBM SP
#   Modified:   04/17/00	increase to 5 pairs at 12z
#   Modified:   05/19/00	create perturbation at any two resolutions,
#                               currently set to create 5 pairs and a 
#                               low-resolution control run at T126
#   Modified:   04/30/01	generalize to run with create any number of
#                               levels and any number of tracer variables
#   Modified:   07/01/03        separate into outer and inner (single pair)
#                               scripts
#   Modified:   06/24/05        modify for relocation and 6-hour breeding
#   Modified:   09/09/05        use one-sided names with two-sided breeding
#
################################################################################

set +xa
echo " ------------------------------------------------------------"
echo "  "
echo "            GLOBAL ENSEMBLE INITIALIZATION "
echo "  "
echo "                `date`     "
echo "  "
echo "                   JOB  $job  "
echo "  "
echo "  "
echo "               FORECAST cycle TIME is $cycle"
echo "  "
echo " ------------------------------------------------------------"
echo "          processing info for this execution"
echo " Home directory is ............................ $HOMEGLOBAL"
echo " Processing directory for files.. ............. $DATA"
echo "  "
echo " Executable file directory is ................. $EXECGLOBAL"
echo " Fixed field directory is ..................... $FIXgsm"
echo " Parameter directory is ....................... $PARMGLOBAL"
echo " Unix control language file is ................ $USHGLOBAL"
echo "  "
echo " Network id is ................................ $NET"
echo " Run id for $com processing is ................ $RUN"
echo "  "
echo " standard output in file ...................... $pgmout"
echo " unique processing id for run ................. $pid"
echo " YES SENDCOM means save com files ............. $SENDCOM"
echo " ------------------------------------------------------------"
set -xa

cd $DATA

################################################################################

relocfact=$relocfact relocflag=$relocflag

(( npairt = npair * 4 ))
nlist=
ipair=0
while (( ipair < npairt )); do
	(( ipair = ipair + 1 ))
	if (( ipair < 10 )); then
		ipair=0$ipair
	fi
	nlist="$nlist $ipair"
done # while (( ipair < npairt ))
echo nlist=$nlist

# explicit jcap specification replaced by specifications in parm file

# these variables specify the resolution of low-resolution perturbation output
# JCAPLR=62
# LEVSLR=28
# LONBLR=192
# LATBLR=94
# NTRACLR=3

# these variables specify the resolution of high-resolution perturbation output
# JCAPHR=126
# LEVSHR=28
# LONBHR=384
# LATBHR=190
# NTRACHR=3

# cfsuffix identifies long forecast cycle 
# associated with this breeding job

if [[ "$cycsuffix" = "true" ]]; then
	export cfsuffix=".cycfs$cyc_fcst"
	export ensshort=yes
else
	export cfsuffix=""
	export ensshort=no
fi # [[ "$cycsuffix" = "true" ]]

echo cyc=$cyc cyc_fcst=$cyc_fcst
echo cycle=$cycle cycle_fcst=$cycle_fcst
echo fcstlong=$fcstlong
echo cycsuffix=$cycsuffix
echo cfsuffix=$cfsuffix
echo ensshort=$ensshort

#export pdycycp=`/nwprod/util/exec/ndate -$fhrp $PDY$cyc`
export pdycycp=`$NDATE -$fhrp $PDY$cyc`
export pdyp=`echo $pdycycp|cut -c1-8`
export cycp=`echo $pdycycp|cut -c9-10`

echo pdycycp=$pdycycp pdyp=$pdyp cycp=$cycp

# cfsuffixp identifies long forecast cycle
# associated with the previous forecast cycle
# from which tracking information will be used

if (( cycp != cyc_fcst )); then
	export cfsuffixp=".cycfs$cyc_fcst"
	export ensshortp=yes
else
	export cfsuffixp=""
	export ensshortp=no
fi  #(( cycp != cyc_fcst ))

echo cfsuffixp=$cfsuffixp
echo ensshortp=$ensshortp

#
# low resolution center analysis
#

if (( nhrpair < npair )); then
      if [ $NEMSIO_IN = .true. ] ; then
	export GFSOUT=sanl.lr.in
	export SFNOUT=sfcanl.lr.in
        export OUTTYP=1
      else
	export SIGOUT=sanl.lr.in
	export SFCOUT=sfcanl.lr.in
        export OUTTYP=2
      fi

	export JCAP=$JCAPLR
	export LEVS=$LEVSLR
	export LONB=$LONBLR
	export LATB=$LATBLR
	export NTRAC=$NTRACLR
	export IDVC=$IDVC
	export NVCOORD=$IDVC
        export nopdpvv=$nopdpvv
        export rdgrid=.true.
        export use_ufo=.true.
	export CHGRESVARS="use_ufo=$use_ufo,rdgrid=$rdgrid,idvc=$idvc,NTRAC=$NTRACLR,NVCOORD=$NVCOORD,IALB=0,nopdpvv=$nopdpvv"
	if (( IDVC == 1 )); then
		export SIGLEVEL=$FIXgsm/global_siglevel.l${LEVS}.txt
	fi
	if (( IDVC == 2 )); then
		export SIGLEVEL=$FIXgsm/global_hyblev.l${LEVS}.txt
	fi

	if [[ -f $COMINgfs/gfs.$cycle.sanl && -f $COMINgfs/gfs.$cycle.sfcanl ]]; then
		export SIGINP=$COMINgfs/gfs.$cycle.sanl
		export SFCINP=$COMINgfs/gfs.$cycle.sfcanl
	else
		echo !!!! FATAL ERROR !!!!
		echo $COMINgfs/gfs.$cycle.sanl and $COMINgfs/gfs.$cycle.sfcanl CANNOT BE FOUND
		exit
	fi # [[ -f $COMINgfs/gfs.$cycle.sanl && -f $COMINgfs/gfs.$cycle.sfcanl ]]
	###teste

	# check for missing or zero-length analysis files

	for file in $SIGINP $SFCINP; do
		if [[ -s $file ]]; then
			ls -al $file
		else
			echo input file $file IS MISSING
			export err=9
			err_chk
		fi # [[ -s $file ]]
	done # for file in $SIGINP $SFCINP
        if [ $NEMSIO_IN = .true. ] ; then
	ojcap=$($nemsioget ${SIGINP} jcap |grep -i "jcap" |awk -F"= " '{print $2}' |awk -F" " '{print $1}')
	olevs=$($nemsioget ${SIGINP} levs |grep -i "levs" |awk -F"= " '{print $2}' |awk -F" " '{print $1}')
        olonb=$($nemsioget ${SIGINP} LONF|grep -i "LONF" |awk -F"= " '{print $2}' |awk -F" " '{print $1}')
        olatb=$($nemsioget ${SIGINP} LATG|grep -i "LATG" |awk -F"= " '{print $2}' |awk -F" " '{print $1}')
        ontrac=$($nemsioget ${SIGINP} NTRAC|grep -i "NTRAC" |awk -F"= " '{print $2}' |awk -F" " '{print $1}')
        oidvc=$($nemsioget ${SIGINP} IDVC|grep -i "IDVC" |awk -F"= " '{print $2}' |awk -F" " '{print $1}')
        else
	ojcap=`$sighdrexec $SIGINP jcap`
	olevs=`$sighdrexec $SIGINP levs`
	olonb=`$sighdrexec $SIGINP lonb`
	olatb=`$sighdrexec $SIGINP latb`
	ontrac=`$sighdrexec $SIGINP ntrac`
	oidvc=`$sighdrexec $SIGINP idvc`
        fi
	runchgres=yes
	if [[ (( JCAP == ojcap )) && (( LEVS == olevs )) && (( LONB == olonb )) && (( LATB == olatb )) && (( NTRAC == ontrac )) && (( IDVC == oidvc )) ]]; then
		runchgres=no
	else
		runchgres=yes
	fi

	if [[ $runchgres = yes ]]; then
		#   if (( IDVC != oidvc )); then
		#     if [[ $oidvc != 2 ]] || [[ LEVS != olevs ]]; then
		#       export SIGLEVEL=$siglevelfile
		#     fi
		#   fi
		echo `date` timing lr chgres before
		#   export OROGRAPHY=${OROGRAPHY:-${FIXgsm}/global_orography.t${JCAP}.grb}
		#   export OROGRAPHY_UF=${OROGRAPHY_UF:-${FIXgsm}/global_orography_uf.t${JCAP}.grb}
		#   export SLMASK=${SLMASK:-${FIXgsm}/global_slmask.t${JCAP}.grb}
		#   export LONSPERLAT=${LONSPERLAT:-${FIXgsm}/global_lonsperlat.t${JCAP}.txt}

                export OROGRAPHY=${OROGRAPHY:-${FIXgsm}/global_orography.t${JCAP}.$LONB.$LATB.rg.grb}
                export OROGRAPHY_UF=${OROGRAPHY_UF:-${FIXgsm}/global_orography_uf.t${JCAP}.$LONB.$LATB.rg.grb}
                export SLMASK=${SLMASK:-${FIXgsm}/global_slmask.t${JCAP}.$LONB.$LATB.rg.grb}
                export LONSPERLAT=${LONSPERLAT:-${FIXgsm}/global_lonsperlat.t${JCAP}.$LONB.$LATB.txt}
                # The SST and SEA_ICE Climate fix file:
                export FNTSFC=${FNTSFC:-$FIXgsm/RTGSST.1982.2012.monthly.clim.grb}  # New for gfs 2014 implementation
                export FNAISC=${FNAISC:-$FIXgsm/CFSR.SEAICE.1982.2012.monthly.clim.grb}  # New for gfs 2014 implementation
                export SOILTYPE_INP=statsgo
                export SOILTYPE_OUT=statsgo
                export VEGTYPE_INP=igbp
                export VEGTYPE_OUT=igbp
                export FNVEGC=${FNVEGC:-${FIXgsm}/global_vegfrac.0.144.decpercent.grb}
                export O3CLIM=${O3CLIM:-${FIXgsm}/global_o3clim.txt}
                export O3FORC=${O3FORC:-${FIXgsm}/global_o3prdlos.f77}
                export H2OFORC=${H2OFORC:-${FIXgsm}global_h2o_pltc.f77}
                export FNALBC2=$FIXgsm/global_albedo4.1x1.grb
                export FNZORC=igbp

		$chgresush >>$pgmout
		echo `date` timing lr chgres after
	else
		cp -fp $SIGINP $SIGOUT
		cp -fp $SFCINP $SFCOUT
	fi # [[ $runchgres = yes ]]
fi # (( nhrpair < npair ))

#
# high resolution center analysis
#

if (( nhrpair > 0 )); then
        if [ $NEMSIO_IN = .true. ] ; then
	export GFSOUT=sanl.hr.in
	export SFNOUT=sfcanl.hr.in
	export NSNOUT=nsnanl.hr.in
        export OUTTYP=1
       else
	export SFCOUT=sfcanl.hr.in
	export SIGOUT=sanl.hr.in
        export OUTTYP=2
       fi

	export JCAP=$JCAPHR
	export LEVS=$LEVSHR
	export LONB=$LONBHR
	export LATB=$LATBHR

export use_ufo=.true.
export IDSL=1
export IDVM=0
export IDVT=21
export LSOIL=4
export IALB=1
export ISOT=1
export nopdpvv=.true.
export LANDICE_OPT=2
export CLIMO_FIELDS_OPT=3
export OUTTYP=1
export IVEGSRC=1
export NVCOORD=0
export RDGRID=.true.
                export SOILTYPE_INP=statsgo
                export SOILTYPE_OUT=statsgo
                export VEGTYPE_INP=igbp
                export VEGTYPE_OUT=igbp
                export O3CLIM=${O3CLIM:-${FIXgsm}/global_o3clim.txt}
                export O3FORC=${O3FORC:-${FIXgsm}/global_o3prdlos.f77}
                export FNGLAC=$FIXgsm/global_glacier.2x2.grb
                export FNMXIC=$FIXgsm/global_maxice.2x2.grb
                export FNTSFC=$FIXgsm/RTGSST.1982.2012.monthly.clim.grb
                export FNSNOC=$FIXgsm/global_snoclim.1.875.grb
                export FNZORC="igbp"
                export FNALBC=$FIXgsm/global_snowfree_albedo.bosu.t$MTNRSL.rg.grb
                export FNALBC2=$FIXgsm/global_albedo4.1x1.grb
                export FNAISC=$FIXgsm/CFSR.SEAICE.1982.2012.monthly.clim.grb
                export FNTG3C=$FIXgsm/global_tg3clim.2.6x1.5.grb
                export FNVEGC=$FIXgsm/global_vegfrac.0.144.decpercent.grb
                export FNVETC=$FIXgsm/global_vegtype.igbp.t$MTNRSL.rg.grb
                export FNSOTC=$FIXgsm/global_soiltype.statsgo.t$MTNRSL.rg.grb
                export FNSMCC=$FIXgsm/global_soilmgldas.t$MTNRSL.grb
                export FNMSKH=$FIXgsm/seaice_newland.grb
                export FNTSFA=""
                export FNACNA=""
                export FNSNOA=""
                export FNVMNC=$FIXgsm/global_shdmin.0.144x0.144.grb
                export FNVMXC=$FIXgsm/global_shdmax.0.144x0.144.grb
                export FNSLPC=$FIXgsm/global_slope.1x1.grb
                export FNABSC=$FIXgsm/global_mxsnoalb.uariz.t$MTNRSL.rg.grb
                export OROGRAPHY_UF=$FIXgsm/global_orography_uf.t$MTNRSL.rg.grb
                export OROGRAPHY=$FIXgsm/global_orography.t$MTNRSL.rg.grb
                export LONSPERLAT=$FIXgsm/global_lonsperlat.t$MTNRSL.txt
                export LONSPERLAR=$FIXgsm/global_lonsperlat.t$MTNRSL.txt
                export SLMASK=$FIXgsm/global_slmask.t$MTNRSL.rg.grb

	export CHGRESVARS="use_ufo=.true.,rdgrid=$RDGRID,idvc=$IDVC,ialb=$IALB,lsoil=$LSOIL,NTRAC=$NTRACLR,NVCOORD=$NVCOORD,nopdpvv=$nopdpvv"
	if (( IDVC == 1 )); then
		export SIGLEVEL=$FIXgsm/global_siglevel.l${LEVS}.txt
	fi
	if (( IDVC == 2 )); then
		export SIGLEVEL=$FIXgsm/global_hyblev.l${LEVS}.txt
	fi

	if [[ -f $COMINgfs/gfs.$cycle.sanl && -f $COMINgfs/gfs.$cycle.sfcanl ]]; then
		export SIGINP=$COMINgfs/gfs.$cycle.sanl
		export SFCINP=$COMINgfs/gfs.$cycle.sfcanl
		export NSTINP=$COMINgfs/gfs.$cycle.nsnanl
	else
		echo !!!! FATAL ERROR !!!!
		echo $COMINgfs/gfs.$cycle.sanl and $COMINgfs/gfs.$cycle.sfcanl CANNOT BE FOUND
		exit
	fi # [[ -f $COMINgfs/gfs.$cycle.sanl && -f $COMINgfs/gfs.$cycle.sfcanl ]]

	# check for missing or zero-length analysis files

	for file in $SIGINP $SFCINP $NSTINP; do
		if [[ -s $file ]]; then
			ls -al $file
		else
			echo input file $file IS MISSING
			export err=9
			err_chk
		fi # [[ -s $file ]]
	done # for file in $SIGINP $SFCINP $NSTINP

        if [ $NEMSIO_IN = .true. ] ; then
	ojcap=$($nemsioget ${SIGINP} jcap |grep -i "jcap" |awk -F"= " '{print $2}' |awk -F" " '{print $1}')
	olevs=$($nemsioget ${SIGINP} levs |grep -i "levs" |awk -F"= " '{print $2}' |awk -F" " '{print $1}')
        olonb=$($nemsioget ${SIGINP} LONF|grep -i "LONF" |awk -F"= " '{print $2}' |awk -F" " '{print $1}')
        olatb=$($nemsioget ${SIGINP} LATG|grep -i "LATG" |awk -F"= " '{print $2}' |awk -F" " '{print $1}')
        ontrac=$($nemsioget ${SIGINP} NTRAC|grep -i "NTRAC" |awk -F"= " '{print $2}' |awk -F" " '{print $1}')
        oidvc=$($nemsioget ${SIGINP} IDVC|grep -i "IDVC" |awk -F"= " '{print $2}' |awk -F" " '{print $1}')
        else
	ojcap=`$sighdrexec $SIGINP jcap`
	olevs=`$sighdrexec $SIGINP levs`
	olonb=`$sighdrexec $SIGINP lonb`
	olatb=`$sighdrexec $SIGINP latb`
	ontrac=`$sighdrexec $SIGINP ntrac`
	oidvc=`$sighdrexec $SIGINP idvc`
        fi
	if [[ (( JCAP == ojcap )) && (( LEVS == olevs )) && (( LONB == olonb )) && (( LATB == olatb )) && (( NTRAC == ontrac )) && (( IDVC == oidvc )) ]]; then
		runchgres=no
	else
		runchgres=yes
	fi

	if [[ $runchgres = yes ]]; then
		#   if [[ $IDVC = 2 ]]; then
		#     if [[ $oidvc != 2 ]] || [[ LEVS != olevs ]]; then
		#       export SIGLEVEL=$siglevelfile
		#       export NVCOORD=2
		#     fi
		#   fi
		echo `date` timing hr chgres before
		#   export OROGRAPHY=${OROGRAPHY:-${FIXgsm}/global_orography.t${JCAP}.grb}
		#   export OROGRAPHY_UF=${OROGRAPHY_UF:-${FIXgsm}/global_orography_uf.t${JCAP}.grb}
		#   export SLMASK=${SLMASK:-${FIXgsm}/global_slmask.t${JCAP}.grb}
		#   export LONSPERLAT=${LONSPERLAT:-${FIXgsm}/global_lonsperlat.t${JCAP}.txt}
 

		$chgresush >>$pgmout
		echo `date` timing hr chgres after
	else
		cp -fp $SIGINP $SIGOUT
		cp -fp $SFCINP $SFCOUT
		cp -fp $NSTINP $NSNOUT
	fi # [[ $runchgres = yes ]]
fi # (( nhrpair > 0 ))

wait

#
# begin relocation splitting section for c00
#
echo relocflag=$relocflag

(( relocpertflag = relocflag ))
export relocflag
export relocpertflag

if (( relocpertflag == 1 )); then
	# test for files necessary for relocation
	if [[ ! -s $COMSFCSIGP/gec00.t${cycp}z.sf$fhrp ]]; then
		export relocpertflag=0
	fi
	if [[ ! -s $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 ]]; then
		export relocpertflag=0
		echo $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 does not exist
	fi
fi # (( relocpertflag == 1 ))

echo HHH TEST 1
if (( relocpertflag == 1 )); then
	echo Separate the storm and environment forecast fields for c00 setup begin

	yy=`echo $PDY|cut -c3-4`
	echo yy=$yy

	# RLW 20131003 modify to point to experimental data
	#if [[ -s /com/gfs/prod/gfs.$PDY/gfs.$cycle.pgrbf00 ]]; then
	export gfsdir=$COMINgfs
	testfile=gfs.$cycle.master.grbf00
	if [[ -s $gfsdir/$testfile ]]; then
		# f00 gfs tracking for relocation
		export cmodel=gfs00
		COM_HOLD=$COM
		export COM=$COMOUT/$cyc/init
		echo `date` extrkr.sh before
		sh ${extrkrsh:-$HOMEgefs/util/ush/extrkr.sh}
		echo `date` extrkr.sh after
		COM=$COM_HOLD
		cat $COMIN/$cyc/init/zgfs.${cycle}.cyclone.trackatcfunix >trackatcfunix.in
	else # [[ -s $gfsdir/$testfile ]]
		# replaced by f00 gfs tracking above but retained for retrospective runs
		if [[ -e $COMINgfs/avn.${cycle}.cyclone.trackatcfunix ]]; then
			cat $COMINgfs/avn.${cycle}.cyclone.trackatcfunix >trackatcfunix.in
		else
			echo $COMINgfs/avn.${cycle}.cyclone.trackatcfunix DOES NOT EXIST
			touch trackatcfunix.in
		fi # [[ -e $COMINgfs/avn.${cycle}.cyclone.trackatcfunix ]]
	fi # [[ -s $gfsdir/$testfile ]]
	ls -al trackatcfunix.in

	if [[ -f $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 ]]; then
		cp -f $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 tcvitals.in
	else
		echo $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 DOES NOT EXIST
		touch tcvitals.in
	fi # [[ -f $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 ]]
	ls -al tcvitals.in

	#DHOU XZHOU changed, production OK?, DH changed it back
	#  $USHgsm/syndataxtrack.sh $PDY $cyc tcvitals.in trackatcfunix.in tcvitals.as
	$USHgefs/syndataxtrack.sh $PDY $cyc tcvitals.in trackatcfunix.in tcvitals.as #ZEUS

	cp -f $COMSFCSIGP/gec00.t${cycp}z.sf$fhrp gec00_presep

	# 20131111 RLW added this missing line
	taufound=no
	for tauprefix in w x y z; do
		if [[ $tauprefix = w ]]; then
			cyc_fcst_t=00
		elif [[ $tauprefix = x ]]; then
			cyc_fcst_t=06
		elif [[ $tauprefix = y ]]; then
			cyc_fcst_t=12
		elif [[ $tauprefix = z ]]; then
			cyc_fcst_t=18
		else
			cyc_fcst_t=cyc_fcst
		fi # [[ $tauprefix = w ]]
		# 20131130 RLW add touch so this file will exist when linked and read
		touch tracks.atcfunix.$cyc_fcst_t
		for file in $COMTRACKP/${tauprefix}[pc]??.t${cycp}z.cyclone.trackatcfunix; do
			if [[ -s $file ]]; then
				cat $file >>tracks.atcfunix.$cyc_fcst_t
				taufound=yes
			fi
		done # for file in $COMTRACKP/${tauprefix}[pc]??.t${cycp}z.cyclone.trackatcfunix
		if [[ "$taufound" = "no" ]]; then
			if (( cyc_fcst == cycp )); then
				for file in $COMTRACKP/a[pc]??.t${cycp}z.cyclone.trackatcfunix; do
					if [[ -s $file ]]; then
						cat $file >>tracks.atcfunix.$cyc_fcst_t
						taufound=yes
					fi
				done # for file in $COMTRACKP/a[pc]??.t${cycp}z.cyclone.trackatcfunix
			fi
		fi
	done  #for tauprefix in w x y z
	if [[ "$taufound" = "no" ]]; then
		export relocpertflag=0
	fi

	echo Separate the storm and environment forecast fields for c00 setup end
fi # (( relocpertflag == 1 ))
echo HHH TEST 2

#DHOU, XZHOU added this if block
execseparate=$EXECgefs/gefs_vortex_separate

if (( relocpertflag == 1 )); then
	echo Separate the storm and environment forecast fields for c00 begin

	ln -s -f tcvitals.as fort.11

	#ln -s -f $FIXgsm/global_slmask.t$JCAPHR.$LONB.$LATB.grb    fort.12
	ln -s -f $SLMASK    fort.12

	ln -s -f tracks.atcfunix.$cycp      fort.40
	ln -s -f gec00_presep              fort.21

	ln -s -f gec00_env              fort.51
	ln -s -f gec00_strm              fort.71

	export gesfhr=$fhrp
	export ensm=c00

	echo `date` $execseparate before
	echo $gesfhr $ensm | $aprun_gec00 $execseparate
	filtrccc=$?
	echo `date` $execseparate after

	ls -al gec00_presep gec00_env gec00_strm

	export relocpertflag=0
	if (( filtrccc == 0 )); then
		if [[ -s gec00_strm ]]; then
			echo c0 storm file was created
			cp -f gec00_strm gec00_strm.c2
			export relocpertflag=1
		else
			echo c0 storm file was not created
		fi # [[ -s gec00_strm ]]
	else
		echo SEPARATION FAILED FOR control c00 filtrccc=$filtrccc
	fi # (( filtrccc == 0 ))

	echo Separate the storm and environment forecast fields for c00 end
fi # (( relocpertflag == 1 ))
echo relocflag=$relocflag relocpertflag=$relocpertflag
#
# end relocation splitting section for c00
#

echo
echo `date` $0 poe separate begin
echo

ls -al poescript*
rm -rf poescript*

(( itask = 0 ))
while (( itask < initseparatetasks )); do
	echo 'echo `date` ############ poescript'" $itask begin">>poescript.$itask
	(( itask = itask + 1 ))
done # while (( itask < initseparatetasks ))

(( itask = 0 ))
for ipair in $nlist; do
	echo npair=$npair
	if (( ipair <= npair )); then
		(( ipairh = ipair ))
	elif (( ipair <= 2 * npair )); then
		(( ipairh = ipair - npair ))
	elif (( ipair <= 3 * npair )); then
		(( ipairh = ipair - 2 * npair ))
	else
		(( ipairh = ipair - 3 * npair ))
	fi # (( ipair <= npair ))
	echo 'echo `date` ###### `uname -a` ######'" $ipair $ipairh begin">>poescript.$itask
	###testb
	###teste
	if (( ipairh > nhrpair )); then
		echo "$USHgefs/gefs_init_pair_separate.sh $ipair $npairt $nhrpair $JCAPLR $LEVSLR $LATBLR $LONBLR $NTRACLR $fhrp $inflag $outflag $relocfact >ushout.separate.$ipair 2>&1" >>poescript.$itask
	else
		echo "$USHgefs/gefs_init_pair_separate.sh $ipair $npairt $nhrpair $JCAPHR $LEVSHR $LATBHR $LONBHR $NTRACHR $fhrp $inflag $outflag $relocfact >ushout.separate.$ipair 2>&1" >>poescript.$itask
	fi
	echo 'echo `date` ###### `uname -a` ######'" $ipair $ipairh end">>poescript.$itask

	(( itask = itask + 1 ))
	if (( itask == initseparatetasks )); then
		(( itask = 0 ))
	fi
done # for ipair in $nlist

(( itask = 0 ))
while (( itask < initseparatetasks )); do
	echo 'echo `date` ############ poescript'" $itask end">>poescript.$itask
	echo
	chmod 755 poescript.$itask
	ls -al poescript.$itask
	echo
	cat poescript.$itask
	echo
	echo "poescript.$itask" >>poescript
	(( itask = itask + 1 ))
done # while (( itask < initseparatetasks ))

echo
chmod 755 poescript
ls -al $poescript
echo
cat poescript
echo
cp -pr poescript cmdfile

echo
echo before ls before poe
echo

pwd
ls -ablp
echo
echo DATA=$DATA before poe
#### kate 4/24/2012 #####
echo "APRUN=$APRUN"
export MP_CMDFILE=poescript
export MP_PGMMODEL=mpmd
export MP_LABELIO=yes
export MP_INFOLEVEL=3
export MP_STDOUTMODE=unordered

rm mpmd_cmdfile
ln -s $MP_CMDFILE mpmd_cmdfile
$APRUN 

echo DATA=$DATA after poe
pwd
ls -ablp

echo
echo after ls after poe
echo

for ipair in $nlist; do
	file=ushout.separate.$ipair
	echo "############################### file=$file begin #######################"
	cat $file
	echo "############################### file=$file end ##########################"
	echo
done

echo
echo `date` $0 poe separate end
echo

###testb
#if [[ $envir = prod ]] || [[ $envir = para ]] || [[ $envir = test ]]; then
###teste
msg='ENDED NORMALLY.'
postmsg "$jlogfile" "$msg"

################# END OF SCRIPT #######################
###testb
#else
#  echo skip delete for now
#fi
###teste
echo `date` $0 end
