#!/bin/ksh
###testb
# lines between ###testb and ###teste not needed for production
###teste
echo `date` $0 begin
################################################################################
#   Script:	exgefs_init.sh.sms
#
#   Author:	Mark Iredell
#   Date:	1997 January 08
#
#   Steward:	Richard Wobus
#   Center:	Environmental Modeling Center
#   Phone:	(301) 763-8000 x7712
#
#   Abstract:	Creates initial conditions for the global ensemble
#       	by perturbing the analysis with growing modes
#               extracted from the previous day's ensemble forecasts.
#       	This script is called by jobs JENS0 and JENS2 and calls
#               the utility script enstr_pair.sh to process each pair.
#
#   Modified:   12/11/98	replace hardwired globampl with fixed file
#                               save growth rate output file
#   Modified:   06/08/99	dummy script made to hold over on IBM until real
#                               exenstr.sh.sms script is ready
#   Modified:   09/09/99	modified for IBM SP
#   Modified:   04/17/00	increase to 5 pairs at 12z
#   Modified:   05/19/00	create perturbation at any two resolutions,
#                               currently set to create 5 pairs and a 
#                               low-resolution control run at T126
#   Modified:   04/30/01	generalize to run with create any number of
#                               levels and any number of tracer variables
#   Modified:   07/01/03        separate into outer and inner (single pair)
#                               scripts
#   Modified:   06/24/05        modify for relocation and 6-hour breeding
#   Modified:   09/09/05        use one-sided names with two-sided breeding
#
################################################################################

set +xa
echo " ------------------------------------------------------------"
echo "  "
echo "            GLOBAL ENSEMBLE INITIALIZATION "
echo "  "
echo "                `date`     "
echo "  "
echo "                   JOB  $job  "
echo "  "
echo "  "
echo "               FORECAST cycle TIME is $cycle"
echo "  "
echo " ------------------------------------------------------------"
echo "          processing info for this execution"
echo " Home directory is ............................ $HOMEGLOBAL"
echo " Processing directory for files.. ............. $DATA"
echo "  "
echo " Executable file directory is ................. $EXECGLOBAL"
echo " Fixed field directory is ..................... $FIXgsm"
echo " Parameter directory is ....................... $PARMGLOBAL"
echo " Unix control language file is ................ $USHGLOBAL"
echo "  "
echo " Network id is ................................ $NET"
echo " Run id for $com processing is ................ $RUN"
echo "  "
echo " standard output in file ...................... $pgmout"
echo " unique processing id for run ................. $pid"
echo " YES SENDCOM means save com files ............. $SENDCOM"
echo " ------------------------------------------------------------"
set -xa

cd $DATA

################################################################################

relocfact=$relocfact relocflag=$relocflag


if [[ "$cycsuffix" = "true" ]]; then
	export cfsuffix=".cycfs$cyc_fcst"
	export ensshort=yes
else
	export cfsuffix=""
	export ensshort=no
fi # [[ "$cycsuffix" = "true" ]]

echo cyc=$cyc cyc_fcst=$cyc_fcst
echo cycle=$cycle cycle_fcst=$cycle_fcst
echo fcstlong=$fcstlong
echo cycsuffix=$cycsuffix
echo cfsuffix=$cfsuffix
echo ensshort=$ensshort

#export pdycycp=`/nwprod/util/exec/ndate -$fhrp $PDY$cyc`
export pdycycp=`$NDATE -$fhrp $PDY$cyc`
export pdyp=`echo $pdycycp|cut -c1-8`
export cycp=`echo $pdycycp|cut -c9-10`

echo pdycycp=$pdycycp pdyp=$pdyp cycp=$cycp

# cfsuffixp identifies long forecast cycle
# associated with the previous forecast cycle
# from which tracking information will be used

if (( cycp != cyc_fcst )); then
	export cfsuffixp=".cycfs$cyc_fcst"
	export ensshortp=yes
else
	export cfsuffixp=""
	export ensshortp=no
fi  #(( cycp != cyc_fcst ))

echo cfsuffixp=$cfsuffixp
echo ensshortp=$ensshortp

#
# high resolution center analysis
#

	if [[ -f $COMINgfs/gfs.$cycle.atmanl.nemsio && -f $COMINgfs/gfs.$cycle.sfcanl.nemsio ]]; then
		export SIGINP=$COMINgfs/gfs.$cycle.atmanl.nemsio
		export SFCINP=$COMINgfs/gfs.$cycle.sfcanl.nemsio
#		export NSTINP=$COMINgfs/gfs.$cycle.nstanl.nemsio
		echo $COMINgfs/gfs.$cycle.atmanl.nemsio and $COMINgfs/gfs.$cycle.sfcanl.nemsio  FOUND
	else
		echo !!!! FATAL ERROR !!!!
		echo $COMINgfs/gfs.$cycle.atmanl.nemsio and $COMINgfs/gfs.$cycle.sfcanl.nemsio CANNOT BE FOUND
		exit
	fi # [[ -f $COMINgfs/gfs.$cycle.atmanl.nemsio && -f $COMINgfs/gfs.$cycle.sfcanl.nemsio ]]

	# check for missing or zero-length analysis files

	for file in $SIGINP $SFCINP; do
		if [[ -s $file ]]; then
			ls -al $file
		else
			echo input file $file IS MISSING
			export err=9
			err_chk
		fi # [[ -s $file ]]
	done # for file in $SIGINP $SFCINP



#
# begin relocation splitting section for c00
#
echo relocflag=$relocflag

(( relocpertflag = relocflag ))
export relocflag
export relocpertflag

if (( relocpertflag == 1 )); then
	# test for files necessary for relocation
	if [[ ! -s $COMSFCSIGP/gec00.t${cycp}z.sf$fhrp ]]; then
		export relocpertflag=0
	fi
	if [[ ! -s $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 ]]; then
		export relocpertflag=0
		echo $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 does not exist
	fi
fi # (( relocpertflag == 1 ))

echo HHH TEST 1
if (( relocpertflag == 1 )); then
	echo Separate the storm and environment forecast fields for c00 setup begin

	yy=`echo $PDY|cut -c3-4`
	echo yy=$yy

	# RLW 20131003 modify to point to experimental data
	#if [[ -s /com/gfs/prod/gfs.$PDY/gfs.$cycle.pgrbf00 ]]; then
	export gfsdir=$COMINgfs
	testfile=gfs.$cycle.master.grbf00
	if [[ -s $gfsdir/$testfile ]]; then
		# f00 gfs tracking for relocation
		export cmodel=gfs00
		COM_HOLD=$COM
		export COM=$COMOUT/$cyc/init
		echo `date` extrkr.sh before
		sh ${extrkrsh:-$HOMEgefs/util/ush/extrkr.sh}
		echo `date` extrkr.sh after
		COM=$COM_HOLD
		cat $COMIN/$cyc/init/zgfs.${cycle}.cyclone.trackatcfunix >trackatcfunix.in
	else # [[ -s $gfsdir/$testfile ]]
		# replaced by f00 gfs tracking above but retained for retrospective runs
		if [[ -e $COMINgfs/avn.${cycle}.cyclone.trackatcfunix ]]; then
			cat $COMINgfs/avn.${cycle}.cyclone.trackatcfunix >trackatcfunix.in
		else
			echo $COMINgfs/avn.${cycle}.cyclone.trackatcfunix DOES NOT EXIST
			touch trackatcfunix.in
		fi # [[ -e $COMINgfs/avn.${cycle}.cyclone.trackatcfunix ]]
	fi # [[ -s $gfsdir/$testfile ]]
	ls -al trackatcfunix.in

	if [[ -f $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 ]]; then
		cp -f $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 tcvitals.in
	else
		echo $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 DOES NOT EXIST
		touch tcvitals.in
	fi # [[ -f $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 ]]
	ls -al tcvitals.in

	#DHOU XZHOU changed, production OK?, DH changed it back
	#  $USHgsm/syndataxtrack.sh $PDY $cyc tcvitals.in trackatcfunix.in tcvitals.as
	$USHgefs/syndataxtrack.sh $PDY $cyc tcvitals.in trackatcfunix.in tcvitals.as #ZEUS

	cp -f $COMSFCSIGP/gec00.t${cycp}z.sf$fhrp gec00_presep

	# 20131111 RLW added this missing line
	taufound=no
        tauprefix=m
        cyc_fcst_t=$cycp
		# 20131130 RLW add touch so this file will exist when linked and read
		touch tracks.atcfunix.$cyc_fcst_t
		for file in $COMTRACKP/${tauprefix}???.t${cycp}z.cyclone.trackatcfunix; do
			if [[ -s $file ]]; then
				cat $file >>tracks.atcfunix.$cyc_fcst_t
				taufound=yes
			fi
		done # for file in $COMTRACKP/${tauprefix}???.t${cycp}z.cyclone.trackatcfunix
	if [[ "$taufound" = "no" ]]; then
		export relocpertflag=0
	fi
fi # (( relocpertflag == 1 ))
        echo relocpertflag=$relocpertflag


echo HHH TEST 2

#DHOU, XZHOU added this if block
execseparate=$EXECgefs/gefs_vortex_separate

if (( relocpertflag == 1 )); then
	echo Separate the storm and environment forecast fields for c00 begin

	ln -s -f tcvitals.as fort.11

	#ln -s -f $FIXgsm/global_slmask.t$JCAPHR.$LONB.$LATB.grb    fort.12
#	ln -s -f $SLMASK    fort.12

	ln -s -f tracks.atcfunix.$cycp      fort.40
	ln -s -f gec00_presep              fort.21

	ln -s -f gec00_env              fort.51
	ln -s -f gec00_strm              fort.71

	export gesfhr=$fhrp
	export ensm=000

	echo `date` $execseparate before
	echo $gesfhr $ensm | $aprun_gec00 $execseparate
	filtrccc=$?
	echo `date` $execseparate after

	ls -al gec00_presep gec00_env gec00_strm

	export relocpertflag=0
	if (( filtrccc == 0 )); then
		if [[ -s gec00_strm ]]; then
			echo c0 storm file was created
			cp -f gec00_strm gec00_strm.c2
			export relocpertflag=1
		else
			echo c0 storm file was not created
		fi # [[ -s gec00_strm ]]
	else
		echo SEPARATION FAILED FOR control c00 filtrccc=$filtrccc
	fi # (( filtrccc == 0 ))

	echo Separate the storm and environment forecast fields for c00 end
fi # (( relocpertflag == 1 ))
echo relocflag=$relocflag relocpertflag=$relocpertflag
#
# end relocation splitting section for c00
#

echo
echo `date` $0 poe separate begin
echo

ls -al poescript*
rm -rf poescript*

(( itask = 0 ))
while (( itask < initseparatetasks )); do
	echo 'echo `date` ############ poescript'" $itask begin">>poescript.$itask
	(( itask = itask + 1 ))
done # while (( itask < initseparatetasks ))

(( itask = 0 ))
for ipair in $nlist; do
	echo npair=$npair
	if (( ipair <= npair )); then
		(( ipairh = ipair ))
	elif (( ipair <= 2 * npair )); then
		(( ipairh = ipair - npair ))
	elif (( ipair <= 3 * npair )); then
		(( ipairh = ipair - 2 * npair ))
	else
		(( ipairh = ipair - 3 * npair ))
	fi # (( ipair <= npair ))
	echo 'echo `date` ###### `uname -a` ######'" $ipair $ipairh begin">>poescript.$itask
	###testb
	###teste
	if (( ipairh > nhrpair )); then
		echo "$USHgefs/gefs_init_pair_separate.sh $ipair $npairt $nhrpair $JCAPLR $LEVSLR $LATBLR $LONBLR $NTRACLR $fhrp $inflag $outflag $relocfact >ushout.separate.$ipair 2>&1" >>poescript.$itask
	else
		echo "$USHgefs/gefs_init_pair_separate.sh $ipair $npairt $nhrpair $JCAPHR $LEVSHR $LATBHR $LONBHR $NTRACHR $fhrp $inflag $outflag $relocfact >ushout.separate.$ipair 2>&1" >>poescript.$itask
	fi
	echo 'echo `date` ###### `uname -a` ######'" $ipair $ipairh end">>poescript.$itask

	(( itask = itask + 1 ))
	if (( itask == initseparatetasks )); then
		(( itask = 0 ))
	fi
done # for ipair in $nlist

(( itask = 0 ))
while (( itask < initseparatetasks )); do
	echo 'echo `date` ############ poescript'" $itask end">>poescript.$itask
	echo
	chmod 755 poescript.$itask
	ls -al poescript.$itask
	echo
	cat poescript.$itask
	echo
	echo "poescript.$itask" >>poescript
	(( itask = itask + 1 ))
done # while (( itask < initseparatetasks ))

echo
chmod 755 poescript
ls -al $poescript
echo
cat poescript
echo
cp -pr poescript cmdfile

echo
echo before ls before poe
echo

pwd
ls -ablp
echo
echo DATA=$DATA before poe
#### kate 4/24/2012 #####
echo "APRUN=$APRUN"
export MP_CMDFILE=poescript
export SCR_CMDFILE=$MP_CMDFILE  # Used by mpiserial on Theia
export MP_PGMMODEL=mpmd
export MP_LABELIO=yes
export MP_INFOLEVEL=3
export MP_STDOUTMODE=unordered

rm mpmd_cmdfile
ln -s $MP_CMDFILE mpmd_cmdfile
$APRUN 

echo DATA=$DATA after poe
pwd
ls -ablp

echo
echo after ls after poe
echo

for ipair in $nlist; do
	file=ushout.separate.$ipair
	echo "############################### file=$file begin #######################"
	cat $file
	echo "############################### file=$file end ##########################"
	echo
done

echo
echo `date` $0 poe separate end
echo

###testb
#if [[ $envir = prod ]] || [[ $envir = para ]] || [[ $envir = test ]]; then
###teste
msg='ENDED NORMALLY.'
postmsg "$jlogfile" "$msg"

################# END OF SCRIPT #######################
###testb
#else
#  echo skip delete for now
#fi
###teste
echo `date` $0 end
