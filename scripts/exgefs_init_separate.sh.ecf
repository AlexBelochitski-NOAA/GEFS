#!/bin/ksh
###testb
# lines between ###testb and ###teste not needed for production
###teste
echo `date` $0 begin
################################################################################
#   Script:	exgefs_init.sh.sms
#
#   Author:	Mark Iredell
#   Date:	1997 January 08
#
#   Steward:	Richard Wobus
#   Center:	Environmental Modeling Center
#   Phone:	(301) 763-8000 x7712
#
#   Abstract:	Creates initial conditions for the global ensemble
#       	by perturbing the analysis with growing modes
#               extracted from the previous day's ensemble forecasts.
#       	This script is called by jobs JENS0 and JENS2 and calls
#               the utility script enstr_pair.sh to process each pair.
#
#   Modified:   12/11/98	replace hardwired globampl with fixed file
#                               save growth rate output file
#   Modified:   06/08/99	dummy script made to hold over on IBM until real
#                               exenstr.sh.sms script is ready
#   Modified:   09/09/99	modified for IBM SP
#   Modified:   04/17/00	increase to 5 pairs at 12z
#   Modified:   05/19/00	create perturbation at any two resolutions,
#                               currently set to create 5 pairs and a 
#                               low-resolution control run at T126
#   Modified:   04/30/01	generalize to run with create any number of
#                               levels and any number of tracer variables
#   Modified:   07/01/03        separate into outer and inner (single pair)
#                               scripts
#   Modified:   06/24/05        modify for relocation and 6-hour breeding
#   Modified:   09/09/05        use one-sided names with two-sided breeding
#
################################################################################

set +xa
echo " ------------------------------------------------------------"
echo "  "
echo "            GLOBAL ENSEMBLE INITIALIZATION "
echo "  "
echo "                `date`     "
echo "  "
echo "                   JOB  $job  "
echo "  "
echo "  "
echo "               FORECAST cycle TIME is $cycle"
echo "  "
echo " ------------------------------------------------------------"
echo "          processing info for this execution"
echo " Home directory is ............................ $HOMEGLOBAL"
echo " Processing directory for files.. ............. $DATA"
echo "  "
echo " Executable file directory is ................. $EXECGLOBAL"
echo " Fixed field directory is ..................... $FIXgsm"
echo " Parameter directory is ....................... $PARMGLOBAL"
echo " Unix control language file is ................ $USHGLOBAL"
echo "  "
echo " Network id is ................................ $NET"
echo " Run id for $com processing is ................ $RUN"
echo "  "
echo " standard output in file ...................... $pgmout"
echo " unique processing id for run ................. $pid"
echo " YES SENDCOM means save com files ............. $SENDCOM"
echo " ------------------------------------------------------------"
set -xa

cd $DATA

################################################################################

relocfact=$relocfact relocflag=$relocflag


if [[ "$cycsuffix" = "true" ]]; then
	export cfsuffix=".cycfs$cyc_fcst"
	export ensshort=yes
else
	export cfsuffix=""
	export ensshort=no
fi # [[ "$cycsuffix" = "true" ]]

echo cyc=$cyc cyc_fcst=$cyc_fcst
echo cycle=$cycle cycle_fcst=$cycle_fcst
echo fcstlong=$fcstlong
echo cycsuffix=$cycsuffix
echo cfsuffix=$cfsuffix
echo ensshort=$ensshort

#export pdycycp=`/nwprod/util/exec/ndate -$fhrp $PDY$cyc`
export pdycycp=`$NDATE -$fhrp $PDY$cyc`
export pdyp=`echo $pdycycp|cut -c1-8`
export cycp=`echo $pdycycp|cut -c9-10`

echo pdycycp=$pdycycp pdyp=$pdyp cycp=$cycp

# cfsuffixp identifies long forecast cycle
# associated with the previous forecast cycle
# from which tracking information will be used

if (( cycp != cyc_fcst )); then
	export cfsuffixp=".cycfs$cyc_fcst"
	export ensshortp=yes
else
	export cfsuffixp=""
	export ensshortp=no
fi  #(( cycp != cyc_fcst ))

echo cfsuffixp=$cfsuffixp
echo ensshortp=$ensshortp

#
# high resolution center analysis
#

	if [[ -f $COMINgfs/gfs.$cycle.atmanl.nemsio && -f $COMINgfs/gfs.$cycle.sfcanl.nemsio ]]; then
		export SIGINP=$COMINgfs/gfs.$cycle.atmanl.nemsio
		export SFCINP=$COMINgfs/gfs.$cycle.sfcanl.nemsio
#		export NSTINP=$COMINgfs/gfs.$cycle.nstanl.nemsio
		echo $COMINgfs/gfs.$cycle.atmanl.nemsio and $COMINgfs/gfs.$cycle.sfcanl.nemsio  FOUND
	else
		echo !!!! FATAL ERROR !!!!
		echo $COMINgfs/gfs.$cycle.atmanl.nemsio and $COMINgfs/gfs.$cycle.sfcanl.nemsio CANNOT BE FOUND
		exit
	fi # [[ -f $COMINgfs/gfs.$cycle.atmanl.nemsio && -f $COMINgfs/gfs.$cycle.sfcanl.nemsio ]]

	# check for missing or zero-length analysis files

	for file in $SIGINP $SFCINP; do
		if [[ -s $file ]]; then
			ls -al $file
		else
			echo input file $file IS MISSING
			export err=9
			err_chk
		fi # [[ -s $file ]]
	done # for file in $SIGINP $SFCINP



#
# begin relocation splitting section for c00
#
echo relocflag=$relocflag

(( relocpertflag = relocflag ))
export relocflag
export relocpertflag

if (( relocpertflag == 1 )); then
	# test for files necessary for relocation
	if [[ ! -s $COMSFCSIGP/gec00.t${cycp}z.sf$fhrp ]]; then
		export relocpertflag=0
	fi
	if [[ ! -s $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 ]]; then
		export relocpertflag=0
		echo $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 does not exist
	fi
fi # (( relocpertflag == 1 ))

echo HHH TEST 1
if (( relocpertflag == 1 )); then
	echo Separate the storm and environment forecast fields for c00 setup begin

	yy=`echo $PDY|cut -c3-4`
	echo yy=$yy

	# RLW 20131003 modify to point to experimental data
	#if [[ -s /com/gfs/prod/gfs.$PDY/gfs.$cycle.pgrbf00 ]]; then
	export gfsdir=$COMINgfs
	testfile=gfs.$cycle.master.grbf00
	if [[ -s $gfsdir/$testfile ]]; then
		# f00 gfs tracking for relocation
		export cmodel=gfs00
		COM_HOLD=$COM
		export COM=$COMOUT/$cyc/init
		echo `date` extrkr.sh before
		sh ${extrkrsh:-$HOMEgefs/util/ush/extrkr.sh}
		echo `date` extrkr.sh after
		COM=$COM_HOLD
		cat $COMIN/$cyc/init/zgfs.${cycle}.cyclone.trackatcfunix >trackatcfunix.in
	else # [[ -s $gfsdir/$testfile ]]
		# replaced by f00 gfs tracking above but retained for retrospective runs
		if [[ -e $COMINgfs/avn.${cycle}.cyclone.trackatcfunix ]]; then
			cat $COMINgfs/avn.${cycle}.cyclone.trackatcfunix >trackatcfunix.in
		else
			echo $COMINgfs/avn.${cycle}.cyclone.trackatcfunix DOES NOT EXIST
			touch trackatcfunix.in
		fi # [[ -e $COMINgfs/avn.${cycle}.cyclone.trackatcfunix ]]
	fi # [[ -s $gfsdir/$testfile ]]
	ls -al trackatcfunix.in

	if [[ -f $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 ]]; then
		cp -f $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 tcvitals.in
	else
		echo $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 DOES NOT EXIST
		touch tcvitals.in
	fi # [[ -f $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 ]]
	ls -al tcvitals.in

	#DHOU XZHOU changed, production OK?, DH changed it back
	#  $USHgsm/syndataxtrack.sh $PDY $cyc tcvitals.in trackatcfunix.in tcvitals.as
	$USHgefs/syndataxtrack.sh $PDY $cyc tcvitals.in trackatcfunix.in tcvitals.as #ZEUS

	cp -f $COMSFCSIGP/gec00.t${cycp}z.sf$fhrp gec00_presep
	cp -f $COMSFCSIGP/gec00.t${cycp}z.sf$fhrp gec00_env

	# 20131111 RLW added this missing line
	taufound=no
        tauprefix=m
        cyc_fcst_t=$cycp
		# 20131130 RLW add touch so this file will exist when linked and read
		touch tracks.atcfunix.$cyc_fcst_t
		for file in $COMTRACKP/${tauprefix}???.t${cycp}z.cyclone.trackatcfunix; do
			if [[ -s $file ]]; then
				cat $file >>tracks.atcfunix.$cyc_fcst_t
				taufound=yes
			fi
		done # for file in $COMTRACKP/${tauprefix}???.t${cycp}z.cyclone.trackatcfunix
	if [[ "$taufound" = "no" ]]; then
		export relocpertflag=0
	fi
fi # (( relocpertflag == 1 ))
        echo relocpertflag=$relocpertflag


echo HHH TEST 2

#DHOU, XZHOU added this if block
execseparate=$EXECgefs/gefs_vortex_separate

#
#  relocation splitting section for c00
#

echo
echo `date` $0 poe separate begin
echo

ls -al poescript*
rm -rf poescript*
    (( itask = 0 ))
           (( imem0 = 0 ))
           (( imema = 0 ))
# For c00
	echo 'echo `date` ############ poescript'" $itask begin">>poescript.$itask
	echo 'echo `date` ###### `uname -a` ######'" mem=$imem start">>poescript.$itask
		echo "$USHgefs/gefs_init_separate.sh $imema $imem0 $fhrp $inflag $relocfact >ushout.separate.$itask 2>&1" >>poescript.$itask
	echo 'echo `date` ###### `uname -a` ######'" mem=$imema end">>poescript.$itask

#  Select EnKF members for four cycling
                case $cyc in
                        (00) (( nlist_start = 1 )) ;;
                        (06) (( nlist_start = nmem_enkf / 4 + 1  ));;
                        (12) (( nlist_start = 2 * nmem_enkf / 4 + 1 ));;
                        (18) (( nlist_start = 3 * nmem_enkf / 4 + 1  )) ;;
                esac # $cyc


    (( nlist_end = nlist_start + npert ))
    (( itask = 1 ))
    (( imem = nlist_start ))
    echo EnKF members from $nlist_start to $nlist_end are selected for $cyc cycle
     while (( imem <= nlist_end )) ; do
           (( imem0 = imem - nlist_end + 1 ))
        if ((  imem > nmem_enkf )); then 
                (( imema = imem - nmem_enkf )) 
        else
                (( imema = imem  )) 
        fi
        cmem=$(printf %03i $imema)
        memchar="mem$cmem"
        memchars="m$cmem"
	echo 'echo `date` ############ poescript'" $itask begin">>poescript.$itask
	echo 'echo `date` ###### `uname -a` ######'" mem=$imem start">>poescript.$itask
		echo "$USHgefs/gefs_init_separate.sh $imema $imem0 $fhrp $inflag $relocfact >ushout.separate.$itask 2>&1" >>poescript.$itask
	echo 'echo `date` ###### `uname -a` ######'" mem=$imema end">>poescript.$itask

	(( itask = itask + 1 ))
        (( imem = imem + 1 ))
      done


        (( itask = 0 ))
while (( itask <= npert  )); do
	chmod 755 poescript.$itask
	ls -al poescript.$itask
	echo
	cat poescript.$itask
	echo
	echo "poescript.$itask" >>poescript
	(( itask = itask + 1 ))
done # while (( itask < npert ))

echo
chmod 755 poescript
ls -al $poescript
echo
cat poescript
echo
cp -pr poescript cmdfile

echo
echo before ls before poe
echo

pwd
ls -ablp
echo
echo DATA=$DATA before poe
#### kate 4/24/2012 #####
echo "APRUN=$APRUN"
export MP_CMDFILE=poescript
export SCR_CMDFILE=$MP_CMDFILE  # Used by mpiserial on Theia
export MP_PGMMODEL=mpmd
export MP_LABELIO=yes
export MP_INFOLEVEL=3
export MP_STDOUTMODE=unordered

rm mpmd_cmdfile
ln -s $MP_CMDFILE mpmd_cmdfile
$APRUN 

echo DATA=$DATA after poe
pwd
ls -ablp

echo
echo after ls after poe
echo

for itask in {0..$npert}; do
	file=ushout.separate.$itask
	echo "############################### file=$file begin #######################"
	cat $file
	echo "############################### file=$file end ##########################"
	echo
done

echo
echo `date` $0 poe separate end
echo

###testb
#if [[ $envir = prod ]] || [[ $envir = para ]] || [[ $envir = test ]]; then
###teste
msg='ENDED NORMALLY.'
postmsg "$jlogfile" "$msg"

################# END OF SCRIPT #######################
###testb
#else
#  echo skip delete for now
#fi
###teste
echo `date` $0 end
