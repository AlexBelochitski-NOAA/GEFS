#!/bin/ksh
###testb
# lines between ###testb and ###teste not needed for production
###teste
echo `date` $0 begin
################################################################################
#   Script:	exgefs_init.sh.sms
#
#   Author:	Mark Iredell
#   Date:	1997 January 08
#
#   Steward:	Richard Wobus
#   Center:	Environmental Modeling Center
#   Phone:	(301) 763-8000 x7712
#
#   Abstract:	Creates initial conditions for the global ensemble
#       	by perturbing the analysis with growing modes
#               extracted from the previous day's ensemble forecasts.
#       	This script is called by jobs JENS0 and JENS2 and calls
#               the utility script enstr_pair.sh to process each pair.
#
#   Modified:   12/11/98	replace hardwired globampl with fixed file
#                               save growth rate output file
#   Modified:   06/08/99	dummy script made to hold over on IBM until real
#                               exenstr.sh.sms script is ready
#   Modified:   09/09/99	modified for IBM SP
#   Modified:   04/17/00	increase to 5 pairs at 12z
#   Modified:   05/19/00	create perturbation at any two resolutions,
#                               currently set to create 5 pairs and a 
#                               low-resolution control run at T126
#   Modified:   04/30/01	generalize to run with create any number of
#                               levels and any number of tracer variables
#   Modified:   07/01/03        separate into outer and inner (single pair)
#                               scripts
#   Modified:   06/24/05        modify for relocation and 6-hour breeding
#   Modified:   09/09/05        use one-sided names with two-sided breeding
#
################################################################################

set +xa
echo " ------------------------------------------------------------"
echo "  "
echo "            GLOBAL ENSEMBLE INITIALIZATION "
echo "  "
echo "                `date`     "
echo "  "
echo "                   JOB  $job  "
echo "  "
echo "  "
echo "               FORECAST cycle TIME is $cycle"
echo "  "
echo " ------------------------------------------------------------"
echo "          processing info for this execution"
echo " Home directory is ............................ $HOMEGLOBAL"
echo " Processing directory for files.. ............. $DATA"
echo "  "
echo " Executable file directory is ................. $EXECGLOBAL"
echo " Fixed field directory is ..................... $FIXGLOBAL"
echo " Parameter directory is ....................... $PARMGLOBAL"
echo " Unix control language file is ................ $USHGLOBAL"
echo "  "
echo " Network id is ................................ $NET"
echo " Run id for $com processing is ................ $RUN"
echo "  "
echo " standard output in file ...................... $pgmout"
echo " unique processing id for run ................. $pid"
echo " YES SENDCOM means save com files ............. $SENDCOM"
echo " ------------------------------------------------------------"
set -xa

cd $DATA
  
################################################################################

relocfact=$relocfact relocflag=$relocflag

(( npairt = npair * 4 ))
nlist=
ipair=0
while (( ipair < npairt ))
do
  (( ipair = ipair + 1 ))
  if (( ipair < 10 )); then
    ipair=0$ipair
  fi
  nlist="$nlist $ipair"
done
echo nlist=$nlist

# explicit jcap specification replaced by specifications in parm file
  
# these variables specify the resolution of low-resolution perturbation output
# JCAPLR=62
# LEVSLR=28
# LONBLR=192
# LATBLR=94
# NTRACLR=3

# these variables specify the resolution of high-resolution perturbation output
# JCAPHR=126
# LEVSHR=28
# LONBHR=384
# LATBHR=190
# NTRACHR=3

# cfsuffix identifies long forecast cycle 
# associated with this breeding job

if [[ "$cycsuffix" = "true" ]]; then
  export cfsuffix=".cycfs$cyc_fcst"
  export ensshort=yes
else
  export cfsuffix=""
  export ensshort=no
fi

echo cyc=$cyc cyc_fcst=$cyc_fcst
echo cycle=$cycle cycle_fcst=$cycle_fcst
echo fcstlong=$fcstlong
echo cycsuffix=$cycsuffix
echo cfsuffix=$cfsuffix
echo ensshort=$ensshort

#export pdycycp=`/nwprod/util/exec/ndate -$fhrp $PDY$cyc`
export pdycycp=`$NDATE -$fhrp $PDY$cyc`
export pdyp=`echo $pdycycp|cut -c1-8`
export cycp=`echo $pdycycp|cut -c9-10`

echo pdycycp=$pdycycp pdyp=$pdyp cycp=$cycp

# cfsuffixp identifies long forecast cycle
# associated with the previous forecast cycle
# from which tracking information will be used

if (( cycp != cyc_fcst )); then
  export cfsuffixp=".cycfs$cyc_fcst"
  export ensshortp=yes
else
  export cfsuffixp=""
  export ensshortp=no
fi

echo cfsuffixp=$cfsuffixp
echo ensshortp=$ensshortp

#
# low resolution center analysis
#

if (( nhrpair < npair )); then

  export SIGOUT=sanl.lr.in
  export SFCOUT=sfcanl.lr.in
  export JCAP=$JCAPLR
  export LEVS=$LEVSLR
  export LONB=$LONBLR
  export LATB=$LATBLR
  export NTRAC=$NTRACLR
  export IDVC=$IDVC
  export NVCOORD=$IDVC
  export nopdpvv=$nopdpvv
  export OUTTYP=$OUTTYP
export LSOIL=4
export IDRT=4
export CLIMO_FIELDS_OPT=3
export LANDICE_OPT=2
export SOILTYPE_INP=statsgo
export SOILTYPE_OUT=zobler
export VEGTYPE_INP=igbp
export VEGTYPE_OUT=sib
export SEA_ICE_THRESHLD_OUTPUT="0.50"
  export CHGRESVARS="use_ufo=.true.,idvc=$IDVC,OUTTYP=$OUTTYP,NTRAC=$NTRACLR,NVCOORD=$NVCOORD,IALB=0,idvt=21,idsl=1,IDVM=0,nopdpvv=$nopdpvv"
  if (( IDVC == 1 )); then
    export SIGLEVEL=$FIXgsm/global_siglevel.l${LEVS}.txt
  fi
  if (( IDVC == 2 )); then
    export SIGLEVEL=$FIXgsm/global_hyblev.l${LEVS}.txt
  fi
  if [ $NEMSIO_IN = .true. ]; then
    if [[ -f $COMINgfs/gfs.$cycle.atmanl.nemsio && -f $COMINgfs/gfs.$cycle.sfcanl.nemsio ]]; then
      export SIGINP=$COMINgfs/gfs.$cycle.atmanl.nemsio
      $getnsttf $COMINgfs/gfs.$cycle.sfcanl.nemsio $COMINgfs/gfs.$cycle.sfcanl.nemsio $DATA/gfs.$cycle.sfcanl.nemsio
      getnsttfrc=$?
      if (( getnsttfrc == 0 )); then
        echo `date` $getnsttf after
         export SFCINP=$DATA/gfs.$cycle.sfcanl.nemsio
      else
        echo !!! FATAL ERROR !!
        echo `date` $getnsttf failed
        exit
      fi
    else
      echo !!!! FATAL ERROR !!!!
      echo $COMINgfs/gfs.$cycle.atmanl.nemsio,$COMINgfs/gfs.$cycle.sfcanl.nemsio and $COMINgfs/gfs.$cycle.nstanl.nemsio CANNOT BE FOUND
      exit
    fi
  else

    if [[ -f $COMINgfs/gfs.$cycle.sanl && -f $COMINgfs/gfs.$cycle.sfcanl ]]; then
      export SIGINP=$COMINgfs/gfs.$cycle.sanl
      export SFCINP=$COMINgfs/gfs.$cycle.sfcanl
    else
      echo !!!! FATAL ERROR !!!!
      echo $COMINgfs/gfs.$cycle.sanl and $COMINgfs/gfs.$cycle.sfcanl CANNOT BE FOUND
      exit
    fi
  fi
###teste

  # check for missing or zero-length analysis files

  for file in $SIGINP $SFCINP
  do
    if [[ -s $file ]]; then
      ls -al $file
    else
      echo input file $file IS MISSING
      export err=9
      err_chk
    fi
  done
#check if ENKF has same resolution as GEFS
  if [ $NEMSIO_IN = .true. ]; then
         runchgres=yes
  else
     ojcap=`$sighdrexec $SIGINP jcap`
     olevs=`$sighdrexec $SIGINP levs`
     olonb=`$sighdrexec $SIGINP lonb`
     olatb=`$sighdrexec $SIGINP latb`
     ontrac=`$sighdrexec $SIGINP ntrac`
     oidvc=`$sighdrexec $SIGINP idvc`
     runchgres=yes
     if (( JCAP == ojcap )); then
        if (( LEVS == olevs )); then
          if (( LONB == olonb )); then
            if (( LATB == olatb )); then
               if (( NTRAC == ontrac )); then
	         if (( IDVC == oidvc )); then
	            runchgres=no
	         fi
               fi
            fi
         fi
       fi
     fi
  fi

  if [[ $runchgres = yes ]]; then
#   if (( IDVC != oidvc )); then
#     if [[ $oidvc != 2 ]] || [[ LEVS != olevs ]]; then
#       export SIGLEVEL=$siglevelfile
#     fi
#   fi
    echo `date` timing lr chgres before
#   export OROGRAPHY=${OROGRAPHY:-${FIXGLOBAL}/global_orography.t${JCAP}.grb}
#   export OROGRAPHY_UF=${OROGRAPHY_UF:-${FIXGLOBAL}/global_orography_uf.t${JCAP}.grb}
#   export SLMASK=${SLMASK:-${FIXGLOBAL}/global_slmask.t${JCAP}.grb}
#   export LONSPERLAT=${LONSPERLAT:-${FIXGLOBAL}/global_lonsperlat.t${JCAP}.txt}
    export OROGRAPHY=${OROGRAPHY:-${FIXgsm}/global_orography.t${JCAP}.$LONB.$LATB.grb}
    export OROGRAPHY_UF=${OROGRAPHY_UF:-${FIXgsm}/global_orography_uf.t${JCAP}.$LONB.$LATB.grb}
    export SLMASK=${SLMASK:-${FIXgsm}/global_slmask.t${JCAP}.$LONB.$LATB.grb}
    export LONSPERLAT=${LONSPERLAT:-${FIXgsm}/global_lonsperlat.t${JCAP}.$LONB.$LATB.txt}
# The SST and SEA_ICE Climate fix file:
    export FNTSFC=${FNTSFC:-$FIXgsm/RTGSST.1982.2012.monthly.clim.grb}  # New for gfs 2014 implementation
    export FNAISC=${FNAISC:-$FIXgsm/CFSR.SEAICE.1982.2012.monthly.clim.grb}  # New for gfs 2014 implementation
    export FNALBC2=$FIXgsm/global_albedo4.1x1.grb
    export FNZORC=sib
    $chgresush >>$pgmout
    echo `date` timing lr chgres after
  else
    cp -fp $SIGINP $SIGOUT
    cp -fp $SFCINP $SFCOUT
  fi

fi

#
# high resolution center analysis
#

if (( nhrpair > 0 )); then

  export SIGOUT=sanl.hr.in
  export SFCOUT=sfcanl.hr.in

  export JCAP=$JCAPHR
  export LEVS=$LEVSHR
  export LONB=$LONBHR
  export LATB=$LATBHR
  export NTRAC=$NTRACHR
  export IDVC=$IDVC
  export NVCOORD=$IDVC
  export nopdpvv=$nopdpvv
  export OUTTYP=$OUTTYP
export LSOIL=4
export IDRT=4
export CLIMO_FIELDS_OPT=3
export LANDICE_OPT=2
export SOILTYPE_INP=statsgo
export SOILTYPE_OUT=zobler
export VEGTYPE_INP=igbp
export VEGTYPE_OUT=sib
export SEA_ICE_THRESHLD_OUTPUT="0.50"
  export CHGRESVARS="use_ufo=.true.,idvc=$IDVC,OUTTYP=$OUTTYP,NTRAC=$NTRACLR,NVCOORD=$NVCOORD,IALB=0,idvt=21,idsl=1,IDVM=0,nopdpvv=$nopdpvv"
  if (( IDVC == 1 )); then
    export SIGLEVEL=$FIXgsm/global_siglevel.l${LEVS}.txt
  fi
  if (( IDVC == 2 )); then
    export SIGLEVEL=$FIXgsm/global_hyblev.l${LEVS}.txt
  fi

  if [ $NEMSIO_IN = .true. ]; then
    if [[ -f $COMINgfs/gfs.$cycle.atmanl.nemsio && -f $COMINgfs/gfs.$cycle.sfcanl.nemsio ]]; then
      export SIGINP=$COMINgfs/gfs.$cycle.atmanl.nemsio
      $getnsttf $COMINgfs/gfs.$cycle.sfcanl.nemsio $COMINgfs/gfs.$cycle.sfcanl.nemsio $DATA/gfs.$cycle.sfcanl.nemsio
      getnsttfrc=$?
      if (( getnsttfrc == 0 )); then
        echo `date` $getnsttf after 
         export SFCINP=$DATA/gfs.$cycle.sfcanl.nemsio
      else
        echo !!! FATAL ERROR !! 
        echo `date` $getnsttf failed
        exit
      fi

    else
      echo !!!! FATAL ERROR !!!!
      echo $COMINgfs/gfs.$cycle.atmanl.nemsio,$COMINgfs/gfs.$cycle.sfcanl.nemsio $COMINgfs/gfs.$cycle.nstanl.nemsio CANNOT BE FOUND
      exit
    fi
  else
    if [[ -f $COMINgfs/gfs.$cycle.sanl && -f $COMINgfs/gfs.$cycle.sfcanl ]]; then
      export SIGINP=$COMINgfs/gfs.$cycle.sanl
      export SFCINP=$COMINgfs/gfs.$cycle.sfcanl
    else
      echo !!!! FATAL ERROR !!!!
      echo $COMINgfs/gfs.$cycle.sanl and $COMINgfs/gfs.$cycle.sfcanl CANNOT BE FOUND
      exit
    fi
 fi
  # check for missing or zero-length analysis files

  for file in $SIGINP $SFCINP
  do
    if [[ -s $file ]]; then
      ls -al $file
    else
      echo input file $file IS MISSING
      export err=9
      err_chk
    fi
  done

 if [ $NEMSIO_IN = .true. ]; then
         runchgres=yes
  else

  ojcap=`$sighdrexec $SIGINP jcap`
  olevs=`$sighdrexec $SIGINP levs`
  olonb=`$sighdrexec $SIGINP lonb`
  olatb=`$sighdrexec $SIGINP latb`
  ontrac=`$sighdrexec $SIGINP ntrac`
  oidvc=`$sighdrexec $SIGINP idvc`
  runchgres=yes
  if (( JCAP == ojcap )); then
    if (( LEVS == olevs )); then
    if (( LONB == olonb )); then
    if (( LATB == olatb )); then
      if (( NTRAC == ontrac )); then
	if (( IDVC == oidvc )); then
	  runchgres=no
	fi
      fi
    fi
    fi
    fi
  fi
 fi

  if [[ $runchgres = yes ]]; then
#   if [[ $IDVC = 2 ]]; then
#     if [[ $oidvc != 2 ]] || [[ LEVS != olevs ]]; then
#       export SIGLEVEL=$siglevelfile
#       export NVCOORD=2
#     fi
#   fi
    echo `date` timing hr chgres before
#   export OROGRAPHY=${OROGRAPHY:-${FIXGLOBAL}/global_orography.t${JCAP}.grb}
#   export OROGRAPHY_UF=${OROGRAPHY_UF:-${FIXGLOBAL}/global_orography_uf.t${JCAP}.grb}
#   export SLMASK=${SLMASK:-${FIXGLOBAL}/global_slmask.t${JCAP}.grb}
#   export LONSPERLAT=${LONSPERLAT:-${FIXGLOBAL}/global_lonsperlat.t${JCAP}.txt}
    export OROGRAPHY=${OROGRAPHY:-${FIXgsm}/global_orography.t${JCAP}.$LONB.$LATB.grb}
    export OROGRAPHY_UF=${OROGRAPHY_UF:-${FIXgsm}/global_orography_uf.t${JCAP}.$LONB.$LATB.grb}
    export SLMASK=${SLMASK:-${FIXgsm}/global_slmask.t${JCAP}.$LONB.$LATB.grb}
    export LONSPERLAT=${LONSPERLAT:-${FIXgsm}/global_lonsperlat.t${JCAP}.$LONB.$LATB.txt}
# The SST and SEA_ICE Climate fix file:
    export FNTSFC=${FNTSFC:-$FIXgsm/RTGSST.1982.2012.monthly.clim.grb}  # New for gfs 2014 implementation
    export FNAISC=${FNAISC:-$FIXgsm/CFSR.SEAICE.1982.2012.monthly.clim.grb}  # New for gfs 2014 implementation
    export FNALBC2=$FIXgsm/global_albedo4.1x1.grb
    export FNZORC=sib

    $chgresush >>$pgmout
    echo `date` timing hr chgres after
  else
    cp -fp $SIGINP $SIGOUT
    cp -fp $SFCINP $SFCOUT
  fi

fi

wait

#
# begin relocation splitting section for c00
#
echo relocflag=$relocflag

(( relocpertflag = relocflag ))
export relocflag
export relocpertflag

if (( relocpertflag == 1 )); then
  # test for files necessary for relocation
  if [[ ! -e $COMSFCSIGP/gec00.t${cycp}z.sf$fhrp ]]; then
    export relocpertflag=0
  fi
  if [[ ! -e $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 ]]; then
    export relocpertflag=0
      echo $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 does not exist
  fi
fi

echo HHH TEST 1
if (( relocpertflag == 1 )); then
  echo Separate the storm and environment forecast fields for c00 setup begin

  yy=`echo $PDY|cut -c3-4`
  echo yy=$yy

# RLW 20131003 modify to point to experimental data
  #if [[ -s /com/gfs/prod/gfs.$PDY/gfs.$cycle.pgrbf00 ]]; then
    export gfsdir=$COMINgfs
  testfile=gfs.$cycle.master.grb2f000
  if [[ -s $gfsdir/$testfile ]]; then
  # f00 gfs tracking for relocation
    export cmodel=gfs00
    COM_HOLD=$COM
    export COM=$COMOUT/$cyc/init
    echo `date` extrkr.sh before
    sh ${extrkrsh:-$HOMEgefs/util/ush/extrkr.sh}
    echo `date` extrkr.sh after
    COM=$COM_HOLD
    cat $COMIN/$cyc/init/zgfs.${cycle}.cyclone.trackatcfunix >trackatcfunix.in
  else
    # replaced by f00 gfs tracking above but retained for retrospective runs
    if [[ -e $COMINgfs/avno.${cycle}.cyclone.trackatcfunix ]]; then
      cat $COMINgfs/avno.${cycle}.cyclone.trackatcfunix >trackatcfunix.in
    else
	echo $COMINgfs/avno.${cycle}.cyclone.trackatcfunix DOES NOT EXIST
	touch trackatcfunix.in
    fi
  fi
  ls -al trackatcfunix.in

    if [[ -f $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 ]]; then
      cp -f $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 tcvitals.in
      else
      echo $COMINgfs/gfs.$cycle.syndata.tcvitals.tm00 DOES NOT EXIST
      touch tcvitals.in
    fi
    ls -al tcvitals.in

#DHOU XZHOU changed, production OK?, DH changed it back
#  $USHgsm/syndataxtrack.sh $PDY $cyc tcvitals.in trackatcfunix.in tcvitals.as
 $USHgefs/syndataxtrack.sh $PDY $cyc tcvitals.in trackatcfunix.in tcvitals.as #ZEUS

  cp -f $COMSFCSIGP/gec00.t${cycp}z.sf$fhrp gec00_presep

# 20131111 RLW added this missing line
  taufound=no
  for tauprefix in w x y z
  do
    if [[ $tauprefix = w ]]; then
      cyc_fcst_t=00
    elif [[ $tauprefix = x ]]; then
      cyc_fcst_t=06
    elif [[ $tauprefix = y ]]; then
      cyc_fcst_t=12
    elif [[ $tauprefix = z ]]; then
      cyc_fcst_t=18
    else
      cyc_fcst_t=cyc_fcst
    fi
# 20131130 RLW add touch so this file will exist when linked and read
    touch tracks.atcfunix.$cyc_fcst_t
    for file in $COMTRACKP/${tauprefix}[pc]??.t${cycp}z.cyclone.trackatcfunix
    do
      if [[ -s $file ]]; then
	cat $file >>tracks.atcfunix.$cyc_fcst_t
	taufound=yes
      fi
    done
    if [[ "$taufound" = "no" ]]; then
      if (( cyc_fcst == cycp )); then
	for file in $COMTRACKP/a[pc]??.t${cycp}z.cyclone.trackatcfunix
	do
	  if [[ -s $file ]]; then
	    cat $file >>tracks.atcfunix.$cyc_fcst_t
	    taufound=yes
	  fi
	done
      fi
    fi
  done
  if [[ "$taufound" = "no" ]]; then
    export relocpertflag=0
  fi

  echo Separate the storm and environment forecast fields for c00 setup end
fi
echo HHH TEST 2

#DHOU, XZHOU added this if block
execseparate=$EXECgefs/gefs_vortex_separate

if (( relocpertflag == 1 )); then
  echo Separate the storm and environment forecast fields for c00 begin

  ln -s -f tcvitals.as fort.11

# ln -s -f $FIXGLOBAL/global_slmask.t$JCAPHR.grb    fort.12
  ln -s -f $FIXgsm/global_slmask.t$JCAPHR.$LONB.$LATB.grb    fort.12

  ln -s -f tracks.atcfunix.$cycp      fort.40
  ln -s -f gec00_presep              fort.21

  ln -s -f gec00_env              fort.51
  ln -s -f gec00_strm              fort.71

  export gesfhr=$fhrp
  export ensm=c00

  echo `date` $execseparate before
  echo $gesfhr $ensm | $execseparate
  filtrccc=$?
  echo `date` $execseparate after

  ls -al gec00_presep gec00_env gec00_strm

  export relocpertflag=0
  if (( filtrccc == 0 )); then
    if [[ -s gec00_strm ]]; then
      echo c0 storm file was created
      cp -f gec00_strm gec00_strm.c2
      export relocpertflag=1
    else
      echo c0 storm file was not created
    fi
  else
    echo SEPARATION FAILED FOR control c00 filtrccc=$filtrccc
  fi

  echo Separate the storm and environment forecast fields for c00 end
fi
echo relocflag=$relocflag relocpertflag=$relocpertflag
#
# end relocation splitting section for c00
#

echo
echo `date` $0 poe separate begin
echo

ls -al poescript*
rm -rf poescript*

(( itask = 0 ))
while (( itask < initseparatetasks ))
do
  echo 'echo `date` ############ poescript'" $itask begin">>poescript.$itask
  (( itask = itask + 1 ))
done

(( itask = 0 ))
for ipair in $nlist
do
  echo npair=$npair
  if (( ipair <= npair )); then
    (( ipairh = ipair ))
  elif (( ipair <= 2 * npair )); then
    (( ipairh = ipair - npair ))
  elif (( ipair <= 3 * npair )); then
    (( ipairh = ipair - 2 * npair ))
  else
    (( ipairh = ipair - 3 * npair ))
  fi
  echo 'echo `date` ###### `uname -a` ######'" $ipair $ipairh begin">>poescript.$itask
###testb
###teste
  if (( ipairh > nhrpair )); then
    echo "$USHgefs/gefs_init_pair_separate.sh $ipair $npairt $nhrpair $JCAPLR $LEVSLR $LATBLR $LONBLR $NTRACLR $fhrp $inflag $outflag $relocfact >ushout.separate.$ipair 2>&1" >>poescript.$itask
  else
    echo "$USHgefs/gefs_init_pair_separate.sh $ipair $npairt $nhrpair $JCAPHR $LEVSHR $LATBHR $LONBHR $NTRACHR $fhrp $inflag $outflag $relocfact >ushout.separate.$ipair 2>&1" >>poescript.$itask
  fi
  echo 'echo `date` ###### `uname -a` ######'" $ipair $ipairh end">>poescript.$itask

  (( itask = itask + 1 ))
  if (( itask == initseparatetasks )); then
    (( itask = 0 ))
  fi

done

(( itask = 0 ))
while (( itask < initseparatetasks ))
do
  echo 'echo `date` ############ poescript'" $itask end">>poescript.$itask
  echo
  chmod 755 poescript.$itask
  ls -al poescript.$itask
  echo
  cat poescript.$itask
  echo
  echo "poescript.$itask" >>poescript
  (( itask = itask + 1 ))
done

echo
chmod 755 poescript
ls -al $poescript
echo
cat poescript
echo
cp -pr poescript cmdfile

export MP_HOLDTIME=1000

export MP_PGMMODEL=mpmd
export MP_CMDFILE=poescript
export MP_LABELIO=yes
export MP_INFOLEVEL=3
export MP_STDOUTMODE=unordered

echo
echo before ls before poe
echo

pwd
ls -ablp
echo
echo DATA=$DATA before poe
#### kate 4/24/2012 #####
echo "APRUN=$APRUN"
$APRUN

echo DATA=$DATA after poe
pwd
ls -ablp

echo
echo after ls after poe
echo

for ipair in $nlist
do
  file=ushout.separate.$ipair
  echo "############################### file=$file begin #######################"
  cat $file
  echo "############################### file=$file end ##########################"
  echo
done

echo
echo `date` $0 poe separate end
echo

###testb
#if [[ $envir = prod ]] || [[ $envir = para ]] || [[ $envir = test ]]; then
###teste
msg='ENDED NORMALLY.'
postmsg "$jlogfile" "$msg"

################# END OF SCRIPT #######################
###testb
#else
#  echo skip delete for now
#fi
###teste
echo `date` $0 end
