#!/bin/ksh -l
###testb
# lines between ###testb and ###teste not needed for production
###teste
echo `date` $0 begin
################################################################################
#   Script:	exgefs_init.sh.sms
#
#   Author:	Mark Iredell
#   Date:	1997 January 08
#
#   Steward:	Richard Wobus
#   Center:	Environmental Modeling Center
#   Phone:	(301) 763-8000 x7712
#
#   Abstract:	Creates initial conditions for the global ensemble
#       	by perturbing the analysis with growing modes
#               extracted from the previous day's ensemble forecasts.
#       	This script is called by jobs JENS0 and JENS2 and calls
#               the utility script enstr_pair.sh to process each pair.
#
#   Modified:   12/11/98	replace hardwired globampl with fixed file
#                               save growth rate output file
#   Modified:   06/08/99	dummy script made to hold over on IBM until real
#                               exenstr.sh.sms script is ready
#   Modified:   09/09/99	modified for IBM SP
#   Modified:   04/17/00	increase to 5 pairs at 12z
#   Modified:   05/19/00	create perturbation at any two resolutions,
#                               currently set to create 5 pairs and a 
#                               low-resolution control run at T126
#   Modified:   04/30/01	generalize to run with create any number of
#                               levels and any number of tracer variables
#   Modified:   07/01/03        separate into outer and inner (single pair)
#                               scripts
#   Modified:   06/24/05        modify for relocation and 6-hour breeding
#   Modified:   09/09/05        use one-sided names with two-sided breeding
#   Modified:  12/31/14         Use EnKF util to recenter when no ETR is applied
#
################################################################################

set +xa
echo " ------------------------------------------------------------"
echo "  "
echo "            GLOBAL ENSEMBLE INITIALIZATION "
echo "  "
echo "                `date`     "
echo "  "
echo "                   JOB  $job  "
echo "  "
echo "  "
echo "               FORECAST cycle TIME is $cycle"
echo "  "
echo " ------------------------------------------------------------"
echo "          processing info for this execution"
echo " Home directory is ............................ $HOMEGLOBAL"
echo " Processing directory for files.. ............. $DATA"
echo "  "
echo " Executable file directory is ................. $EXECGLOBAL"
echo " Fixed field directory is ..................... $FIXGLOBAL"
echo " Parameter directory is ....................... $PARMGLOBAL"
echo " Unix control language file is ................ $USHGLOBAL"
echo "  "
echo " Network id is ................................ $NET"
echo " Run id for $com processing is ................ $RUN"
echo "  "
echo " standard output in file ...................... $pgmout"
echo " unique processing id for run ................. $pid"
echo " YES SENDCOM means save com files ............. $SENDCOM"
echo " ------------------------------------------------------------"
set -xa

cd $DATA
################################################################################
# To run EnKF recentering
export XC=${XC}
export GETATMENSMEANEXEC=${GETATMENSMEANEXEC:-${HOMEenkf}/exec/getsigensmeanp_smooth$XC}
export RECENATMPEXEC=${RECENATMPEXEC:-${HOMEenkf}/exec/recentersigp$XC}
echo cyc=$cyc cyc_fcst=$cyc_fcst
echo cycle=$cycle cycle_fcst=$cycle_fcst

################################################################################

echo relocfact=$relocfact relocflag=$relocflag

(( npairt = npair * 4 ))
nlist=
ipair=0
while (( ipair < npairt ))
do
  (( ipair = ipair + 1 ))
  if (( ipair < 10 )); then
    ipair=0$ipair
  fi
  nlist="$nlist $ipair"
done
echo nlist=$nlist
  
# these variables are now set in gefs.parm

# these variables specify the resolution of low-resolution perturbation output
# JCAPLR=62
# LEVSLR=28
# LONBLR=192
# LATBLR=94
# NTRACLR=3

# these variables specify the resolution of high-resolution perturbation output
# JCAPHR=126
# LEVSHR=28
# LONBHR=384
# LATBHR=190
# NTRACHR=3

# cfsuffix identifies long forecast cycle 
# associated with this breeding job

if [[ "$cycsuffix" = "true" ]]; then
  export cfsuffix=".cycfs$cyc_fcst"
  export ensshort=yes
else
  export cfsuffix=""
  export ensshort=no
fi

echo cyc=$cyc cyc_fcst=$cyc_fcst
echo cycle=$cycle cycle_fcst=$cycle_fcst
echo fcstlong=$fcstlong
echo cycsuffix=$cycsuffix
echo cfsuffix=$cfsuffix
echo ensshort=$ensshort

export pdycycp=`$NDATE -$fhrp $PDY$cyc`
export pdyp=`echo $pdycycp|cut -c1-8`
export cycp=`echo $pdycycp|cut -c9-10`

echo pdycycp=$pdycycp pdyp=$pdyp cycp=$cycp


# cfsuffixp identifies long forecast cycle
# associated with the previous forecast cycle
# from which tracking information will be used

if (( cycp != cyc_fcst )); then
  export cfsuffixp=".cycfs$cyc_fcst"
  export ensshortp=yes
else
  export cfsuffixp=""
  export ensshortp=no
fi

echo cfsuffixp=$cfsuffixp
echo ensshortp=$ensshortp


#
# ----------------------- start  ET,  M. Wei, 2005.11.10
echo
echo `date` $0  ET part b begin
echo
#
#globamplm=$globamplm_et
globamplr=$globamplr_et
globamplg=$globamplg_et
itopres=$itopres_et
contop=$contop_et
nlevrs=$nlevrs_et
mxlev=$mxlev_et
nlevmask=$nlevmask_et
b1=$b1_et
b2=$b2_et
b3=$b3_et
smax=$smax_et
if [[ $etflag = no ]]; then
netflag=0
else
netflag=1
fi
mskflag=$mskflag_et
echo globamplr=$globamplr
echo globamplg=$globamplg
echo itopres=$itopres
echo contop=$contop
echo nlevrs=$nlevrs
echo mxlev=$mxlev
echo nlevmask=$nlevmask
echo b1=$b1
echo b2=$b2
echo b3=$b3
echo smax=$smax

cp -f sanl.in.pair01   sanl.in
cp -f sanl.in  sanl.c0
#
#  Make namelist file
#
cat <<EOF >et_namens
  &NAMENS npair1=$npair,jcap=$JCAPHR,ilat=$LATBHR,ilon=$LONBHR,
  levs=$LEVSHR,ntrac=$NTRACHR,inflag=$inflag,icyc=$cyc,
  globamplr=$globamplr,globamplg=$globamplg,itopres=$itopres,
  contop=$contop,nlevrs=$nlevrs,mxlev=$mxlev,
  nlevmask=$nlevmask,smax=$smax,b1=$b1,b2=$b2,b3=$b3,
  netflag=$netflag,mskflag=$mskflag/
EOF
#
echo  "&DATNAMES" >>  et_namens
#
for ip in $nlist;   do
     (( iip = ip ))
     if (( iip < 10 )); then
        iip=0$iip
     fi
     if [[ $parallelinit = no ]]; then
#
#  input ensemble member file names
#
       en1v="en1($ip)='finn.pair${iip}',"
       echo "$en1v" >> et_namens
       en2v="en2($ip)='finp.pair${iip}',"
       echo "$en2v" >> et_namens
#
#  output ensemble member file names
#
       enn1v="enn1($ip)='sanlgm${iip}n',"
       echo "$enn1v" >> et_namens
       enn2v="enn2($ip)='sanlgm${iip}p',"
       echo "$enn2v" >> et_namens
#
     else
       (( ipo = 2 * ip - 1 ))
       en1v="en($ipo)='finn.pair${iip}',"
       echo "$en1v" >> et_namens
       enn1v="enn($ipo)='sanlgm${iip}n',"
       echo "$enn1v" >> et_namens
#
       (( ipe = 2 * ip ))
       en2v="en($ipe)='finp.pair${iip}',"
       echo "$en2v" >> et_namens
       enn2v="enn($ipe)='sanlgm${iip}p',"
       echo "$enn2v" >> et_namens
     fi
done
echo "/" >> et_namens
cat et_namens
# if there are no initial, use backup perts
#
ip=1
iip=0$ip
for tz in t00z t06z t12z t18z;  do
  np=01
  while (( np <= npair )); do
    if [[ ! -s finn.pair${iip}  ]]; then
      ln -s -f  gefs.pertback.${tz}.n${np}.pair${iip} finn.pair${iip}
    fi 
    if [[ ! -s finp.pair${iip}  ]]; then
      ln -s -f  gefs.pertback.${tz}.p${np}.pair${iip} finp.pair${iip}
    fi
    (( ip = ip + 1 ))
    (( iip = ip ))
    if (( iip < 10 )); then
      iip=0$iip
    fi
    (( np = np + 1 ))
    if (( np < 10 )); then
      np=0$np
    fi
  done 
done
#
echo list input files for ET
ls -al | grep -e finn -e finp
#
#
#  run et.exe to read data and solve the matrix
# 
# run et with a mask

###testb
export exe_dir=EXECgefs/exec
if [[ $parallelinit = no ]]; then
  execet=$exe_dir/gefs_init_et
else
  execet=$exe_dir/gefs_init_et_p
fi

if ((mskflag == 2)); then
cp -f $COMINm1/$cyc/track_enkf/TE_SPRD_ave.grd fort.48
cp -f $COMINm1/$cyc/track_enkf/PS_SPRD_ave.grd fort.49
echo using 3D mask of $COMINm1/$cyc/track_enkf/TE_SPRD_ave.grd and PS_SPRD_ave.grd
elif ((mskflag ==3 )); then
       ln -s   $FIXgefs/enkf.geogr.monthly  fort.48
       ln -s   $FIXgefs/enkf.geogr.monthly.ps  fort.49
        echo using mask of $FIXgefs/enkf.geogr.monthly
else
cp -f  $FIXgefs/gefs.geogr.monthly  fort.48
echo using mask of $FIXgefs/gefs.geogr.monthly
fi
# set env variables for running paralell version of ET code
export TARGET_CPU_LIST=-1
export MPI_DSM_DISTRIBUTE
export MPI_SM_POOL=16000
export MP_EAGER_LIMIT=65536
export MP_SINGLE_THREAD=yes
export MP_STDOUTMODE=ordered
# output is labeled by ID
export MP_LABELIO=yes
export MP_SHARED_MEMORY=yes
export MP_ADAPTER_USE=shared
export MP_CPU_USE=multiple
export MP_CSS_INTERRUPT=yes
if [[ $netflag == 0 && $mskflag == 0 ]]; then
  (( recentmem = npair * 2 ))
   case $cyc in
     (00) (( ipair0 = 0  )) ;;
     (06) (( ipair0 = npair   )) ;;
     (12) (( ipair0 = 2 * npair )) ;;
     (18) (( ipair0 = 3 * npair )) ;;
   esac

   (( ipairh = ipair0 + npair ))

   for ipair in $nlist
   do
     if (( ipair > ipair0 && ipair <= ipairh)); then
         (( ipairn = ipair - ipair0  ))
         (( ipairp = ipair - ipair0 + npair ))
#             if (( ipair < 10 )); then
#               ipair=0$ipair
#             fi
             if (( ipairn < 10 )); then
                ipairn=0$ipairn
             fi
             if  (( ipairp < 10 )); then
                ipairp=0$ipairp
              fi
         ln -s   finn.pair${ipair}  fin_mem0$ipairn
         ln -s    finp.pair${ipair}  fin_mem0$ipairp
     else
         cp -pr   finn.pair${ipair}  sanlgm${ipair}n
         cp -pr   finp.pair${ipair}  sanlgm${ipair}p
     fi
  done
  $gefsmpexec $GETATMENSMEANEXEC ./ fin_ensmean fin $recentmem 6 | tee -a $pgmout
  $gefsmpexec $RECENATMPEXEC fin fin_ensmean sanl.in.pair01 sanlgm $recentmem | tee -a $pgmout

   for ipair in $nlist
   do
     if (( ipair > ipair0 && ipair <= ipairh)); then
         (( ipairn = ipair - ipair0  ))
         (( ipairp = ipair - ipair0 + npair ))
             if (( ipairn < 10 )); then
                ipairn=0$ipairn
             fi
             if  (( ipairp < 10 )); then
                ipairp=0$ipairp
              fi
         cp -pr  sanlgm_mem0$ipairn sanlgm${ipair}n
         cp -pr  sanlgm_mem0$ipairp sanlgm${ipair}p
     fi
   done


else
if [[ $parallelinit = no ]]; then
# serial version of et
  echo `date` $execet before
  $execet  < et_namens | tee -a $pgmout
  export err=$?
  err_chk
  echo `date` $execet after
else
# parallel version of et
  echo `date` $execet  MPI ET before
  #  $execet  < et_namens | tee -a $pgmout
  #poe /usrx/local/mpi_trace/utils/launch.x $execet  < et_namens
  #poe hpmcount /usrx/local/mpi_trace/utils/launch.x $execet  < et_namens
  #poe hpmcount $execet  < et_namens
#  poe $execet  < et_namens
$APRUN $execet < et_namens
  export err=$?
  err_chk
  echo `date` $execet  MPI ET after

fi
fi

#
echo change names after ET for gefs_init_pair_combine.sh 
echo npair=$npair
echo  nlist=$nlist

(( missingcount = 0 ))

for ip in $nlist
do
  echo ip=$ip
  if (( ip <= npair )); then
    (( ipairh=ip ))
  elif (( ip <= 2 * npair )); then
    (( ipairh = ip - npair ))
  elif (( ip <= 3 * npair )); then
    (( ipairh = ip - 2 * npair ))
  else
    (( ipairh = ip - 3 * npair ))
  fi
  if (( ipairh < 10 )); then
     ipairh=0${ipairh}
  fi 
  echo final ipairh=$ipairh
#
  if [[ -s sanlgm${ip}n && -s sanlgm${ip}p ]]; then
    mv -f sanlgm${ip}n  sanlgm${ipairh}n.pair${ip}
    mv -f sanlgm${ip}p  sanlgm${ipairh}p.pair${ip}
    cp -f sanl.c0 sanl.c0.pair${ip}
  else
    (( missingcount = missingcount + 1 ))
  fi
done
#
echo
echo `date` $0  ET part b end
echo
echo  ================  list files after the end of  ET
pwd
ls -lt

##############################
# kill this job if data was missing
##############################
if (( missingcount > 0 )); then
  export pgm=gefs_init_et_p
  export err=9
  err_chk
fi

#
# -------end of testing ET, start removing part b, test ET,  M. Wei, 2005.11.10
#

#if [[ $envir = prod ]] || [[ $envir = para ]] || [[ $envir = test ]]; then
###teste
msg='ENDED NORMALLY.'
postmsg "$jlogfile" "$msg"

################# END OF SCRIPT #######################
###testb
#else
#  echo skip delete for now
#fi
###teste
echo `date` $0 end
